Index: src/main/java/com/alibaba/damo/mindopt/Mdo.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/alibaba/damo/mindopt/Mdo.java b/src/main/java/com/alibaba/damo/mindopt/Mdo.java
--- a/src/main/java/com/alibaba/damo/mindopt/Mdo.java	(revision 04a30f71ef197800d26eed246753aad99b81350a)
+++ b/src/main/java/com/alibaba/damo/mindopt/Mdo.java	(revision 1562808c594777f48ccfdb11b85f20aec0f1948c)
@@ -16,6 +16,7 @@
 
 package com.alibaba.damo.mindopt;
 
+import com.alibaba.damo.mindopt.impl.MdoNativeAPI;
 import com.alibaba.damo.mindopt.impl.MdoNativeModel;
 
 public class Mdo {
@@ -88,6 +89,14 @@
     public static final String STR_ATTR_COL_NAME = "ColName";
     public static final String STR_ATTR_ROW_NAME = "RowName";
 
+    // remote attribute names
+    public static final String STR_ATTR_REMOTE_TOKEN = "Remote/Token";
+    public static final String STR_ATTR_REMOTE_DESC = "Remote/Desc";
+    public static final String STR_ATTR_REMOTE_SERVER = "Remote/Server";
+    public static final String STR_ATTR_REMOTE_FILE_MODEL = "Remote/File/Model";
+    public static final String STR_ATTR_REMOTE_FILE_PARAM = "Remote/File/Param";
+    public static final String STR_ATTR_REMOTE_FILE_SOLN = "Remote/File/Soln";
+    public static final String STR_ATTR_REMOTE_FILE_PATH = "Remote/File/Path";
 
     // Solution attribute names
     public static final String INT_ATTR_HAS_SOLUTION = "HasSolution";
@@ -110,6 +119,6 @@
      * @param nativeLibrary full path of mindopt native dynamic library
      */
     public static void load(String nativeLibrary) {
-        MdoNativeModel.load(nativeLibrary);
+        MdoNativeAPI.InstanceHolder.load(nativeLibrary);
     }
 }
Index: src/main/java/com/alibaba/damo/mindopt/impl/MdoMatrixImpl.java
===================================================================
diff --git a/src/main/java/com/alibaba/damo/mindopt/impl/MdoMatrixImpl.java b/src/main/java/com/alibaba/damo/mindopt/impl/MdoMatrixImpl.java
deleted file mode 100644
--- a/src/main/java/com/alibaba/damo/mindopt/impl/MdoMatrixImpl.java	(revision 04a30f71ef197800d26eed246753aad99b81350a)
+++ /dev/null	(revision 04a30f71ef197800d26eed246753aad99b81350a)
@@ -1,756 +0,0 @@
-/**
- * Copyright 1999-2021 Alibaba Cloud All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.alibaba.damo.mindopt.impl;
-
-import com.alibaba.damo.mindopt.*;
-import com.sun.jna.Memory;
-import com.sun.jna.Native;
-import com.sun.jna.Pointer;
-
-import java.util.*;
-
-public class MdoMatrixImpl implements MdoMatrix {
-    public MdoMatrixImpl() {
-        model.createMdl();
-    }
-
-    protected MdoNativeModel model = new MdoNativeModel();
-    protected List<MdoVar> vars = new ArrayList<MdoVar>();
-    protected List<MdoCons> conss = new ArrayList<MdoCons>();
-    protected boolean freed = false;
-
-    private char inverse(char sense) {
-        if (sense == Mdo.LESS_EQUAL) {
-            return Mdo.GREATER_EQUAL;
-        } else if (sense == Mdo.GREATER_EQUAL) {
-            return Mdo.LESS_EQUAL;
-        } else {
-            return Mdo.EQUAL;
-        }
-    }
-
-    protected void syncData(boolean syncConss, boolean syncVars) {
-        if (syncConss) {
-            this.conss.clear();
-            for (int i = 0; i < model.getNumRows(); i++) {
-                this.conss.add(new MdoConsImpl(this, i));
-            }
-        }
-        if (syncVars) {
-            this.vars.clear();
-            for (int i = 0; i < model.getNumCols(); i++) {
-                this.vars.add(new MdoVarImpl(this, i));
-            }
-        }
-    }
-
-    @Override
-    public MdoVar addVar(double lb, double ub, double obj, boolean isInteger, String name) {
-        return addVar(lb, ub, obj, isInteger, null, null, name);
-    }
-
-    @Override
-    public MdoVar addVar(double lb, double ub, double obj, boolean isInteger, MdoCol col, String name) {
-        if (col == null) {
-            return this.addVar(lb, ub, obj, isInteger, null, null, name);
-        } else {
-            MdoCons[] conss = new MdoCons[col.size()];
-            double[] coeffs = new double[col.size()];
-
-            for(int i = 0; i < col.size(); ++i) {
-                conss[i] = col.getCons(i);
-                coeffs[i] = col.getCoeff(i);
-            }
-            return this.addVar(lb, ub, obj, isInteger, conss, coeffs, name);
-        }
-    }
-
-    @Override
-    public MdoVar addVar(double lb, double ub, double obj, boolean isInteger, MdoCons[] conss, double[] coeffs, String name) {
-        int code;
-        Pointer pName = MemoryUtil.charArray(name);
-        if (conss == null || conss.length == 0) {
-            code = model.addCol(
-                    lb, ub, obj, 0,
-                    Pointer.NULL, Pointer.NULL,
-                    pName, isInteger ? 1 : 0
-            );
-        } else {
-            int size = conss.length;
-            Pointer indices = MemoryUtil.intArray(size);
-            Pointer values = MemoryUtil.doubleArray(size);
-            for (int i = 0; i < size; i++) {
-                MemoryUtil.setInt(indices, i, conss[i].getIndex());
-                if (coeffs == null || coeffs.length <= i) {
-                    MemoryUtil.setDouble(values, i, 1);
-                } else {
-                    MemoryUtil.setDouble(values, i, coeffs[i]);
-                }
-            }
-            code = model.addCol(lb, ub, obj, size, indices, values, pName, isInteger ? 1 : 0);
-        }
-        MdoResult.checkResult(code);
-        MdoVar var = new MdoVarImpl(this, vars.size());
-        vars.add(var);
-        return var;
-    }
-
-    @Override
-    public MdoVar[] addVars(int count, boolean isInteger) {
-        MdoVar[] vars = new MdoVar[count];
-        for (int i = 0; i < count; i++) {
-            vars[i] = this.addVar(0, Mdo.INFINITY, 0, isInteger, null);
-        }
-        return vars;
-    }
-
-    @Override
-    public MdoVar[] addVars(double[] lbs, double[] ubs, double[] objs, boolean[] areIntegers, String[] names) {
-        int size = lbs.length;
-        return this.addVars(lbs, ubs, objs, areIntegers, names, 0, size);
-    }
-
-    @Override
-    public MdoVar[] addVars(double[] lbs, double[] ubs, double[] objs, boolean[] areIntegers, String[] names, int start, int len) {
-        if (len < 0) {
-            return null;
-        } else if (len == 0) {
-            return new MdoVar[0];
-        }
-
-        MdoVar[] result = new MdoVar[len];
-        for (int i = start; i < start + len; i++) {
-            result[i - start] = this.addVar(lbs[i], ubs[i], objs[i], areIntegers[i], names == null ? null : names[i]);
-        }
-
-        return result;
-    }
-
-    @Override
-    public MdoVar[] addVars(double[] lbs, double[] ubs, double[] objs, boolean[] areIntegers, MdoCol[] cols, String[] names) {
-        if (lbs.length == 0) {
-            return new MdoVar[0];
-        }
-        MdoVar[] result = new MdoVar[lbs.length];
-        for (int i = 0; i < lbs.length; i++) {
-            result[i] = this.addVar(lbs[i], ubs[i], objs[i], areIntegers[i], cols[i] , names == null ? null : names[i]);
-        }
-        return result;
-    }
-
-    @Override
-    public MdoCons addCons(MdoExprLinear lhs, char sense, MdoExprLinear rhs, String name) {
-        MdoExprLinear expr = new MdoExprLinear(lhs);
-        expr.multAdd(-1, rhs);
-        return this.addCons(expr, sense, 0, name);
-    }
-
-    @Override
-    public MdoCons addCons(MdoVar lhs, char sense, MdoVar rhs, String name) {
-        MdoExprLinear expr = new MdoExprLinear();
-        expr.addTerm(1, lhs);
-        expr.addTerm(-1, rhs);
-        return this.addCons(expr, sense, 0, name);
-    }
-
-    @Override
-    public MdoCons addCons(MdoExprLinear lhs, char sense, MdoVar rhs, String name) {
-        MdoExprLinear expr = new MdoExprLinear(lhs);
-        expr.addTerm(-1, rhs);
-        return this.addCons(expr, sense, 0, name);
-    }
-
-    @Override
-    public MdoCons addCons(MdoVar lhs, char sense, MdoExprLinear rhs, String name) {
-        return this.addCons(rhs, inverse(sense), lhs, name);
-    }
-
-    @Override
-    public MdoCons addCons(double lhs, char sense, MdoExprLinear rhs, String name) {
-        return this.addCons(rhs, inverse(sense), lhs, name);
-    }
-
-    @Override
-    public MdoCons addCons(MdoVar lhs, char sense, double rhs, String name) {
-        MdoExprLinear expr = new MdoExprLinear();
-        expr.addTerm(1, lhs);
-        return this.addCons(expr, sense, rhs, name);
-    }
-
-    @Override
-    public MdoCons addCons(double lhs, char sense, MdoVar rhs, String name) {
-        return this.addCons(rhs, inverse(sense), lhs, name);
-    }
-
-    @Override
-    public MdoCons addCons(MdoExprLinear lhs, char sense, double rhs, String name) {
-        MdoExprLinear expr = new MdoExprLinear(lhs);
-
-        if (rhs > Mdo.NEGATIVE_INFINITY && rhs < Mdo.INFINITY) {
-            rhs -= expr.getConstant();
-        }
-
-        expr.purge();
-        int size = expr.size();
-        Pointer indices = MemoryUtil.intArray(size);
-        Pointer values = MemoryUtil.doubleArray(size);
-        Pointer pName = MemoryUtil.charArray(name);
-
-        for (int i = 0; i < expr.size(); i++) {
-            MemoryUtil.setInt(indices, i, expr.getVar(i).getIndex());
-            MemoryUtil.setDouble(values, i, expr.getCoeff(i));
-        }
-
-        double l = rhs;
-        double r = rhs;
-
-        if (sense == Mdo.LESS_EQUAL) {
-            l = Mdo.NEGATIVE_INFINITY;
-        } else if (sense == Mdo.GREATER_EQUAL) {
-            r = Mdo.INFINITY;
-        }
-
-        int code = model.addRow(l, r, size, indices, values, pName);
-        MdoResult.checkResult(code);
-
-        MdoCons cons = new MdoConsImpl(this, conss.size());
-        conss.add(cons);
-        return cons;
-    }
-
-    @Override
-    public MdoCons addRange(MdoExprLinear expr, double lower, double upper, String name) {
-        MdoExprLinear expr1 = new MdoExprLinear(expr);
-
-        if (upper > Mdo.NEGATIVE_INFINITY && upper < Mdo.INFINITY) {
-            upper -= expr.getConstant();
-        }
-
-        if (lower > Mdo.NEGATIVE_INFINITY && lower < Mdo.INFINITY) {
-            lower -= expr.getConstant();
-        }
-
-        expr1.purge();
-        int size = expr1.size();
-        Pointer indices = MemoryUtil.intArray(size);
-        Pointer values = MemoryUtil.doubleArray(size);
-        Pointer pName = MemoryUtil.charArray(name);
-
-        for (int i = 0; i < expr1.size(); i++) {
-            MemoryUtil.setInt(indices, i, expr1.getVar(i).getIndex());
-            MemoryUtil.setDouble(values, i, expr1.getCoeff(i));
-        }
-
-        int code = model.addRow(lower, upper, size, indices, values, pName);
-        MdoResult.checkResult(code);
-
-        MdoCons cons = new MdoConsImpl(this, conss.size());
-        conss.add(cons);
-        return cons;
-    }
-
-    @Override
-    public MdoCons[] addConss(int count) {
-        MdoCons conss[] = new MdoCons[count];
-        for (int i = 0; i < count; i++) {
-            int code = model.addRow(Mdo.NEGATIVE_INFINITY, 0, 0, Pointer.NULL, Pointer.NULL, Pointer.NULL);
-            MdoResult.checkResult(code);
-
-            MdoCons cons = new MdoConsImpl(this, this.conss.size());
-            this.conss.add(cons);
-            conss[i] = cons;
-        }
-        return conss;
-    }
-
-    @Override
-    public MdoCons[] addConss(MdoExprLinear[] lhss, char[] senses, double[] rhss, String[] names) {
-        MdoCons[] conss = new MdoCons[lhss.length];
-        for (int i = 0; i < lhss.length; i++) {
-            conss[i] = this.addCons(lhss[i], senses[i], rhss[i], names == null ? null : names[i]);
-        }
-        return conss;
-    }
-
-    @Override
-    public MdoCons[] addConss(MdoExprLinear[] lhss, char[] senses, double[] rhss, String[] names, int start, int len) {
-        MdoCons[] conss = new MdoCons[len];
-        for (int i = start; i < start + len; i++) {
-            conss[i - start] = this.addCons(lhss[i], senses[i], rhss[i], names == null ? null : names[i]);
-        }
-        return conss;
-    }
-
-    @Override
-    public MdoCons[] addRanges(MdoExprLinear[] exprs, double[] lowers, double[] uppers, String[] names) {
-        MdoCons[] conss = new MdoCons[exprs.length];
-        for (int i = 0; i < exprs.length; i++) {
-            conss[i] = this.addRange(exprs[i], lowers[i], uppers[i], names == null ? null : names[i]);
-        }
-        return conss;
-    }
-
-    @Override
-    public MdoVar getVar(int j) {
-        if (j < 0 || j >= vars.size()) {
-            MdoResult.checkResult(MdoResult.MDO_MODEL_INVALID_COL_IDX.getCode());
-        }
-        return vars.get(j);
-    }
-
-    @Override
-    public MdoCons getCons(int i) {
-        if (i < 0 || i >= conss.size()) {
-            MdoResult.checkResult(MdoResult.MDO_MODEL_INVALID_ROW_IDX.getCode());
-        }
-        return conss.get(i);
-    }
-
-    @Override
-    public MdoVar getVar(String name) {
-        int j = model.getColIndex(MemoryUtil.charArray(name));
-        if (j < 0) {
-            MdoResult.checkResult(MdoResult.MDO_MODEL_INVALID_COL_NAME.getCode());
-        }
-        return vars.get(j);
-    }
-
-    @Override
-    public MdoCons getCons(String name) {
-        int i = model.getRowIndex(MemoryUtil.charArray(name));
-        if (i < 0) {
-            MdoResult.checkResult(MdoResult.MDO_MODEL_INVALID_ROW_NAME.getCode());
-        }
-        return conss.get(i);
-    }
-
-    @Override
-    public MdoVar[] getVars() {
-        return vars.toArray(new MdoVar[0]);
-    }
-
-    @Override
-    public MdoCons[] getConss() {
-        return conss.toArray(new MdoCons[0]);
-    }
-
-    @Override
-    public void deleteVars(MdoVar[] vars) {
-        List<Integer> indices = new ArrayList<Integer>();
-        for (MdoVar var : vars) {
-            indices.add(var.getIndex());
-        }
-
-        Collections.sort(indices);
-        int len = 1;
-        for (int i = 1; i < indices.size(); i++) {
-            if (indices.get(i).intValue() != indices.get(i - 1)) {
-                len++;
-            }
-        }
-
-        Pointer pIndices = MemoryUtil.intArray(len);
-        int offset = 0;
-
-        MemoryUtil.setInt(pIndices, offset++, indices.get(0));
-        for (int i = 1; i < indices.size(); i++) {
-            if (indices.get(i).intValue() != indices.get(i - 1)) {
-                MemoryUtil.setInt(pIndices, offset++, indices.get(i));
-            }
-        }
-
-        MdoResult.checkResult(model.deleteCols(len, pIndices));
-        syncData(false, true);
-    }
-
-    @Override
-    public void deleteConss(MdoCons[] conss) {
-        List<Integer> indices = new ArrayList<Integer>();
-        for (MdoCons cons : conss) {
-            indices.add(cons.getIndex());
-        }
-
-        Collections.sort(indices);
-        int len = 1;
-        for (int i = 1; i < indices.size(); i++) {
-            if (indices.get(i).intValue() != indices.get(i - 1)) {
-                len++;
-            }
-        }
-
-        Pointer pIndices = MemoryUtil.intArray(len);
-        int offset = 0;
-
-        MemoryUtil.setInt(pIndices, offset++, indices.get(0));
-        for (int i = 1; i < indices.size(); i++) {
-            if (indices.get(i).intValue() != indices.get(i - 1)) {
-                MemoryUtil.setInt(pIndices, offset++, indices.get(i));
-            }
-        }
-
-        MdoResult.checkResult(model.deleteRows(len, pIndices));
-        syncData(true, false);
-    }
-
-
-    @Override
-    public MdoCol getCol(MdoVar var) {
-        int j = var.getIndex();
-        Pointer realSize = MemoryUtil.intByReference();
-        Pointer colIndices = MemoryUtil.intArray(1);
-        MemoryUtil.setInt(colIndices, 0, j);
-
-        MdoResult.checkResult(model.getCols(1, colIndices, Pointer.NULL, Pointer.NULL, Pointer.NULL, 0, realSize));
-        MdoCol col = new MdoCol();
-        if (realSize.getInt(0) > 0) {
-            Pointer bgn = MemoryUtil.intArray(2);
-            Pointer indices = MemoryUtil.intArray(realSize.getInt(0));
-            Pointer values = MemoryUtil.doubleArray(realSize.getInt(0));
-            MdoResult.checkResult(model.getCols(1, colIndices, bgn, indices, values, realSize.getInt(0), realSize));
-            for (int i = 0; i < realSize.getInt(0); i++) {
-                double coeff = MemoryUtil.getDouble(values, i);
-                MdoCons cons = conss.get(MemoryUtil.getInt(indices, i));
-                col.addTerm(coeff, cons);
-            }
-        }
-        return col;
-    }
-
-    @Override
-    public MdoExprLinear getExprLinear(MdoCons cons) {
-        int i = cons.getIndex();
-        Pointer realSize = MemoryUtil.intByReference();
-        Pointer rowIndices = MemoryUtil.intArray(1);
-        MemoryUtil.setInt(rowIndices, 0, i);
-
-        MdoResult.checkResult(model.getRows(1, rowIndices, Pointer.NULL, Pointer.NULL, Pointer.NULL, 0, realSize));
-        MdoExprLinear expr = new MdoExprLinear();
-        if (realSize.getInt(0) > 0) {
-            Pointer bgn = MemoryUtil.intArray(2);
-            Pointer indices = MemoryUtil.intArray(realSize.getInt(0));
-            Pointer values = MemoryUtil.doubleArray(realSize.getInt(0));
-            MdoResult.checkResult(model.getRows(1, rowIndices, bgn, indices, values, realSize.getInt(0), realSize));
-            for (int j = 0; j < realSize.getInt(0); j++) {
-                double coeff = MemoryUtil.getDouble(values, j);
-                MdoVar var = vars.get(MemoryUtil.getInt(indices, j));
-                expr.addTerm(coeff, var);
-            }
-        }
-        return expr;
-    }
-
-    @Override
-    public boolean isMinObjSense() {
-        return model.isMinObjSense() != 0;
-    }
-
-    @Override
-    public boolean isMaxObjSense() {
-        return model.isMaxObjSense() != 0;
-    }
-
-    @Override
-    public void setMinObjSense() {
-        model.setMinObjSense();
-    }
-
-    @Override
-    public void setMaxObjSense() {
-        model.setMaxObjSense();
-    }
-
-    @Override
-    public double getObjOffset() {
-        return model.getObjOffset();
-    }
-
-    @Override
-    public void setObjOffset(double objFix) {
-        model.setObjOffset(objFix);
-    }
-
-    @Override
-    public double[] getObjs(MdoVar[] vars) {
-        return getRealAttrVars(Mdo.REAL_ATTR_OBJ, vars);
-    }
-
-    @Override
-    public void setObjs(MdoVar[] vars, double[] vals) {
-        setRealAttrVars(Mdo.REAL_ATTR_OBJ, vars, vals);
-    }
-
-    @Override
-    public double[] getElements(MdoCons[] conss, MdoVar[] vars) {
-        Pointer values = MemoryUtil.doubleArray(conss.length);
-        Pointer rowIndices = MemoryUtil.intArray(conss.length);
-        Pointer colIndices = MemoryUtil.intArray(conss.length);
-
-        for (int i = 0; i < conss.length; i++) {
-            MemoryUtil.setInt(rowIndices, i, conss[i].getIndex());
-            MemoryUtil.setInt(colIndices, i, vars[i].getIndex());
-        }
-
-        MdoResult.checkResult(model.getElements(conss.length, rowIndices, colIndices, values));
-        return values.getDoubleArray(0, conss.length);
-    }
-
-    @Override
-    public void setElements(MdoCons[] conss, MdoVar[] vars, double[] values) {
-        Pointer pValues = MemoryUtil.doubleArray(conss.length);
-        Pointer rowIndices = MemoryUtil.intArray(conss.length);
-        Pointer colIndices = MemoryUtil.intArray(conss.length);
-
-        for (int i = 0; i < conss.length; i++) {
-            MemoryUtil.setInt(rowIndices, i, conss[i].getIndex());
-            MemoryUtil.setInt(colIndices, i, vars[i].getIndex());
-            MemoryUtil.setDouble(pValues, i, values[i]);
-        }
-
-        MdoResult.checkResult(model.setElements(conss.length, rowIndices, colIndices, pValues));
-    }
-
-    @Override
-    public void deleteElements(MdoCons[] conss, MdoVar[] vars) {
-        Pointer rowIndices = MemoryUtil.intArray(conss.length);
-        Pointer colIndices = MemoryUtil.intArray(conss.length);
-
-        for (int i = 0; i < conss.length; i++) {
-            MemoryUtil.setInt(rowIndices, i, conss[i].getIndex());
-            MemoryUtil.setInt(colIndices, i, vars[i].getIndex());
-        }
-
-        MdoResult.checkResult(model.deleteElements(conss.length, rowIndices, colIndices));
-    }
-
-    @Override
-    public void setStrAttrIndex(String att, int index, String val) {
-        MdoResult.checkResult(model.setStrAttrIndex(MemoryUtil.charArray(att), index, MemoryUtil.charArray(val)));
-    }
-
-    @Override
-    public String getStrAttrIndex(String att, int index) {
-        Pointer buffer = new Memory(Mdo.MAX_NATIVE_STR_LEN);
-        MdoResult.checkResult(model.getStrAttrIndex(MemoryUtil.charArray(att), index, Mdo.MAX_NATIVE_STR_LEN, buffer));
-        return Native.toString(buffer.getByteArray(0, Mdo.MAX_NATIVE_STR_LEN));
-    }
-
-    @Override
-    public void setIntAttrIndex(String att, int index, int val) {
-        MdoResult.checkResult(model.setIntAttrIndex(MemoryUtil.charArray(att), index, val));
-    }
-
-    @Override
-    public int getIntAttrIndex(String att, int index) {
-        Pointer n = MemoryUtil.intByReference();
-        MdoResult.checkResult(model.getIntAttrIndex(MemoryUtil.charArray(att), index, n));
-        return n.getInt(0);
-    }
-
-    @Override
-    public void setRealAttrIndex(String att, int index, double val) {
-        MdoResult.checkResult(model.setRealAttrIndex(MemoryUtil.charArray(att), index, val));
-    }
-
-    @Override
-    public double getRealAttrIndex(String att, int index) {
-        Pointer d = MemoryUtil.doubleByReference();
-        MdoResult.checkResult(model.getRealAttrIndex(MemoryUtil.charArray(att), index, d));
-        return d.getDouble(0);
-    }
-
-    @Override
-    public void setIntAttrArray(String att, int start, int len, int[] val) {
-        MdoResult.checkResult(model.setIntAttrArray(MemoryUtil.charArray(att), start, len, MemoryUtil.intArray(val)));
-    }
-
-    @Override
-    public int[] getIntAttrArray(String att, int start, int len) {
-        Pointer val = MemoryUtil.intArray(len);
-        MdoResult.checkResult(model.getIntAttrArray(MemoryUtil.charArray(att), start, len, val));
-        return val.getIntArray(0, len);
-    }
-
-    @Override
-    public void setRealAttrArray(String att, int start, int len, double[] val) {
-        MdoResult.checkResult(model.setRealAttrArray(MemoryUtil.charArray(att), start, len, MemoryUtil.doubleArray(val)));
-    }
-
-    @Override
-    public double[] getRealAttrArray(String att, int start, int len) {
-        Pointer val = MemoryUtil.doubleArray(len);
-        MdoResult.checkResult(model.getRealAttrArray(MemoryUtil.charArray(att), start, len, val));
-        return val.getDoubleArray(0, len);
-    }
-
-    @Override
-    public void setIntAttrVars(String att, MdoVar[] vars, int[] vals) {
-        for (int i = 0; i < vars.length; i++) {
-            MdoVar var = vars[i];
-            setIntAttrIndex(att, var.getIndex(), vals[i]);
-        }
-    }
-
-    @Override
-    public int[] getIntAttrVars(String att, MdoVar[] vars) {
-        int[] vals = new int[vars.length];
-        for (int i = 0; i < vars.length; i++) {
-            MdoVar var = vars[i];
-            vals[i] = getIntAttrIndex(att, var.getIndex());
-        }
-        return vals;
-    }
-
-    @Override
-    public void setRealAttrVars(String att, MdoVar[] vars, double[] vals) {
-        for (int i = 0; i < vars.length; i++) {
-            MdoVar var = vars[i];
-            setRealAttrIndex(att, var.getIndex(), vals[i]);
-        }
-    }
-
-    @Override
-    public double[] getRealAttrVars(String att, MdoVar[] vars) {
-        double[] vals = new double[vars.length];
-        for (int i = 0; i < vars.length; i++) {
-            MdoVar var = vars[i];
-            vals[i] = getRealAttrIndex(att, var.getIndex());
-        }
-        return vals;
-    }
-
-    @Override
-    public void setIntAttrConss(String att, MdoCons[] conss, int[] vals) {
-        for (int i = 0; i < conss.length; i++) {
-            MdoCons cons = conss[i];
-            setIntAttrIndex(att, cons.getIndex(), vals[i]);
-        }
-    }
-
-    @Override
-    public int[] getIntAttrConss(String att, MdoCons[] conss) {
-        int[] vals = new int[conss.length];
-        for (int i = 0; i < conss.length; i++) {
-            MdoCons cons = conss[i];
-            vals[i] = getIntAttrIndex(att, cons.getIndex());
-        }
-        return vals;
-    }
-
-    @Override
-    public void setRealAttrConss(String att, MdoCons[] conss, double[] vals) {
-        for (int i = 0; i < conss.length; i++) {
-            MdoCons cons = conss[i];
-            setRealAttrIndex(att, cons.getIndex(), vals[i]);
-        }
-    }
-
-    @Override
-    public double[] getRealAttrConss(String att, MdoCons[] conss) {
-        double[] vals = new double[conss.length];
-        for (int i = 0; i < conss.length; i++) {
-            MdoCons cons = conss[i];
-            vals[i] = getRealAttrIndex(att, cons.getIndex());
-        }
-        return vals;
-    }
-
-    @Override
-    public void setIntAttr(String att, int val) {
-        MdoResult.checkResult(model.setIntAttr(MemoryUtil.charArray(att), val));
-    }
-
-    @Override
-    public int getIntAttr(String att) {
-        Pointer val = MemoryUtil.intByReference();
-        MdoResult.checkResult(model.getIntAttr(MemoryUtil.charArray(att), val));
-        return val.getInt(0);
-    }
-
-    @Override
-    public void setRealAttr(String att, double val) {
-        MdoResult.checkResult(model.setRealAttr(MemoryUtil.charArray(att), val));
-    }
-
-    @Override
-    public double getRealAttr(String att) {
-        Pointer val = MemoryUtil.doubleByReference();
-        MdoResult.checkResult(model.getRealAttr(MemoryUtil.charArray(att), val));
-        return val.getDouble(0);
-    }
-
-    @Override
-    public void setStrAttr(String att, String val) {
-        MdoResult.checkResult(model.setStrAttr(MemoryUtil.charArray(att), MemoryUtil.charArray(val)));
-    }
-
-    @Override
-    public String getStrAttr(String att) {
-        Pointer buffer = new Memory(Mdo.MAX_NATIVE_STR_LEN);
-        MdoResult.checkResult(model.getStrAttr(MemoryUtil.charArray(att), Mdo.MAX_NATIVE_STR_LEN, buffer));
-        return Native.toString(buffer.getByteArray(0, Mdo.MAX_NATIVE_STR_LEN));
-    }
-
-    @Override
-    public void setStrParam(String par, String val) {
-        MdoResult.checkResult(model.setStrParam(MemoryUtil.charArray(par), MemoryUtil.charArray(val)));
-    }
-
-    @Override
-    public String getStrParam(String par) {
-        Pointer val = new Memory(Mdo.MAX_NATIVE_STR_LEN);
-        MdoResult.checkResult(model.getStrParam(MemoryUtil.charArray(par), Mdo.MAX_NATIVE_STR_LEN, val));
-        return Native.toString(val.getByteArray(0, Mdo.MAX_NATIVE_STR_LEN));
-    }
-
-    @Override
-    public void setIntParam(String par, int val) {
-        MdoResult.checkResult(model.setIntParam(MemoryUtil.charArray(par), val));
-    }
-
-    @Override
-    public int getIntParam(String par) {
-        Pointer val = MemoryUtil.intByReference();
-        MdoResult.checkResult(model.getIntParam(MemoryUtil.charArray(par), val));
-        return val.getInt(0);
-    }
-
-    @Override
-    public void setRealParam(String par, double val) {
-        MdoResult.checkResult(model.setRealParam(MemoryUtil.charArray(par), val));
-    }
-
-    @Override
-    public double getRealParam(String par) {
-        Pointer val = MemoryUtil.doubleByReference();
-        MdoResult.checkResult(model.getRealParam(MemoryUtil.charArray(par), val));
-        return val.getDouble(0);
-    }
-
-    @Override
-    public void free() {
-        if (!freed) {
-            freed = true;
-            model.freeMdl();
-        }
-    }
-
-    @Override
-    protected void finalize() throws Throwable {
-        super.finalize();
-        free();
-    }
-}
Index: src/main/java/com/alibaba/damo/mindopt/impl/MdoNativeAPI.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/alibaba/damo/mindopt/impl/MdoNativeAPI.java b/src/main/java/com/alibaba/damo/mindopt/impl/MdoNativeAPI.java
--- a/src/main/java/com/alibaba/damo/mindopt/impl/MdoNativeAPI.java	(revision 04a30f71ef197800d26eed246753aad99b81350a)
+++ b/src/main/java/com/alibaba/damo/mindopt/impl/MdoNativeAPI.java	(revision 1562808c594777f48ccfdb11b85f20aec0f1948c)
@@ -18,11 +18,22 @@
 
 import com.sun.jna.Callback;
 import com.sun.jna.Library;
+import com.sun.jna.Native;
 import com.sun.jna.Pointer;
 import com.sun.jna.ptr.PointerByReference;
 
-interface MdoNativeAPI extends Library {
-
+public interface MdoNativeAPI extends Library {
+    class InstanceHolder {
+        static MdoNativeAPI INSTANCE;
+        public static MdoNativeAPI get() {
+            return INSTANCE;
+        }
+        public static void load(String libName) {
+            if (INSTANCE == null) {
+                INSTANCE = (MdoNativeAPI) Native.loadLibrary(libName, MdoNativeAPI.class);
+            }
+        }
+    }
     int /* MdoResult */ Mdo_setStrAttrIndex(
             Pointer /* void * */ mdl,
             Pointer /* char * */ att,
@@ -187,6 +198,19 @@
             Pointer /* void * */ userdata
     );
 
+    int /* MdoResult */ Mdo_createEnv(
+            PointerByReference /* void * * */ env
+    );
+
+    int /* MdoResult */ Mdo_createMdlWithEnv(
+            PointerByReference /* void * * */ mdl,
+            Pointer /* void * */ env
+    );
+
+    void /* void */ Mdo_freeEnv(
+            PointerByReference /* void * * */ env
+    );
+
     int /* MdoResult */ Mdo_createMdl(
             PointerByReference /* void * * */ mdl
     );
@@ -450,6 +474,22 @@
             Pointer /* int * */ col_indices,
             Pointer /* double * */ values
     );
+
+    int /* MdoResult */ Mdo_getQuadraticElements(
+            Pointer /* void * */ mdl,
+            int /* int */ size,
+            Pointer /* int * */ col_indices1,
+            Pointer /* int * */ col_indices2,
+            Pointer /* double * */ values
+    );
+
+    int /* MdoResult */ Mdo_setQuadraticElements(
+            Pointer /* void * */ mdl,
+            int /* int */ size,
+            Pointer /* int * */ col_indices1,
+            Pointer /* int * */ col_indices2,
+            Pointer /* double * */ values
+    );
 
     int /* MdoResult */ Mdo_setElements(
             Pointer /* void * */ mdl,
@@ -478,6 +518,21 @@
             Pointer /* int * */ col_indices
     );
 
+    int /* MdoResult */ Mdo_deleteQuadraticElements(
+            Pointer /* void * */ mdl,
+            int /* int */ size,
+            Pointer /* int * */ col_indices1,
+            Pointer /* int * */ col_indices2
+    );
+
+    int /*MdoResult */ Mdo_deleteAllElements(
+            Pointer /* void * */ mdl
+    );
+
+    int /*MdoResult */ Mdo_deleteAllQuadraticElements(
+            Pointer /* void * */ mdl
+    );
+
     int /* MdoResult */ Mdo_setStrParam(
             Pointer /* void * */ mdl,
             Pointer /* char * */ par,
Index: src/main/java/com/alibaba/damo/mindopt/impl/MdoNativeModel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/alibaba/damo/mindopt/impl/MdoNativeModel.java b/src/main/java/com/alibaba/damo/mindopt/impl/MdoNativeModel.java
--- a/src/main/java/com/alibaba/damo/mindopt/impl/MdoNativeModel.java	(revision 04a30f71ef197800d26eed246753aad99b81350a)
+++ b/src/main/java/com/alibaba/damo/mindopt/impl/MdoNativeModel.java	(revision ce1a24e12f8193b9c421115cfcf00ab3d91f3152)
@@ -17,33 +17,24 @@
 package com.alibaba.damo.mindopt.impl;
 
 import com.sun.jna.Callback;
-import com.sun.jna.Native;
 import com.sun.jna.Pointer;
 import com.sun.jna.ptr.PointerByReference;
 
 /**
- * The mindopt native interface, it is strongly recommended to use MdoModel instead
+ * The mindopt model native interface, it is strongly recommended to use MdoModel instead
  */
 public class MdoNativeModel {
-    public static void load(String libraryName) {
-        if (INSTANCE == null) {
-            INSTANCE = (MdoNativeAPI) Native.loadLibrary(libraryName, MdoNativeAPI.class);
-        }
-    }
-
     static MdoNativeAPI inst() {
-        if (INSTANCE == null) {
+        if (MdoNativeAPI.InstanceHolder.get() == null) {
             throw new RuntimeException("Mdo.load() needs to be called at very beginning.");
         }
-        return INSTANCE;
+        return MdoNativeAPI.InstanceHolder.get();
     }
 
     private Pointer getModel() {
         return model.getValue();
     }
-
-    private static MdoNativeAPI INSTANCE;
-    private PointerByReference model = new PointerByReference();
+    PointerByReference model = new PointerByReference();
     /**
      * Change the value of a string-valued row/column attribute.
      * @param att [in] A string-valued row/column attribute.
@@ -1183,7 +1174,7 @@
     }
     /**
      * Retrieve a set of values of all specified elements in the constraint matrix.
-     * @param size [in] Number of elemenets to access.
+     * @param size [in] Number of elements to access.
      * @param row_indices [in] An array that holds the row index of elements to access.
      * @param col_indices [in] An array that holds the column index of elements to access.
      * @param values [in] An array that will hold the current nonzero values of all specified elements in the constraint matrix.
@@ -1205,7 +1196,7 @@
     }
     /**
      * Modify a set of values of all specified elements in the constraint matrix.
-     * @param size [in] Number of elemenets to access.
+     * @param size [in] Number of elements to access.
      * @param row_indices [in] An array that holds the row index of elements to access.
      * @param col_indices [in] An array that holds the column index of elements to access.
      * @param values [in] An array that holds the new nonzero values for all specified elements in the constraint matrix.
@@ -1223,6 +1214,50 @@
                 row_indices,
                 col_indices,
                 values
+        );
+    }
+    /**
+     * Retrieve a set of values of all specified elements in the quadratic matrix of a quadratic program.
+     * @param size [in] Number of elements to access.
+     * @param col_indices1 [in] An array that holds the first variable index of elements to access.
+     * @param col_indices2 [in] An array that holds the second variable index of elements to access.
+     * @param values [out] An array that will hold the current nonzero values of all specified elements.
+     * @return MdoResult code
+     */
+    public int getQuadraticElements(
+            int size,
+            Pointer col_indices1,
+            Pointer col_indices2,
+            Pointer values
+    ) {
+        return inst().Mdo_getQuadraticElements(
+                getModel(),
+                size,
+                col_indices1,
+                col_indices2,
+                values
+        );
+    }
+    /**
+     * Modify a set of values of all specified elements in the quadratic matrix of a quadratic program.
+     * @param size [in] Number of elements to access.
+     * @param col_indices1 [in] An array that holds the first variable index of elements to access.
+     * @param col_indices2 [in] An array that holds the second variable index of elements to access.
+     * @param values [in] An array that holds the new nonzero values for all specified elements.
+     * @return MdoResult code
+     */
+    public int setQuadraticElements(
+            int size,
+            Pointer col_indices1,
+            Pointer col_indices2,
+            Pointer values
+    ) {
+        return inst().Mdo_setQuadraticElements(
+                getModel(),
+                size,
+                col_indices1,
+                col_indices2,
+                values
         );
     }
     /**
@@ -1277,6 +1312,45 @@
         );
     }
     /**
+     * Delete a set of elements from the quadratic matrix of a quadratic program.
+     * @param size [in] Number of elements to be deleted.
+     * @param col_indices1 [in] An array that holds the first variable index of elements to access.
+     * @param col_indices2 [in] An array that holds the second variable index of elements to access.
+     * @return MdoResult code
+     */
+    public int deleteQuadraticElements(
+            int size,
+            Pointer col_indices1,
+            Pointer col_indices2
+    ) {
+        return inst().Mdo_deleteQuadraticElements(
+                getModel(),
+                size,
+                col_indices1,
+                col_indices2
+        );
+    }
+
+    /**
+     *  Delete all elements from the constraint matrix.
+     *  @return MdoResult code.
+     */
+    public int deleteAllElements() {
+        return inst().Mdo_deleteAllElements(
+                getModel()
+        );
+    }
+
+    /**
+     *  Delete all elements from the quadratic matrix of a quadratic program.
+     *  @return MdoResult code
+     */
+    public int deleteAllQuadraticElements() {
+        return inst().Mdo_deleteAllQuadraticElements(
+                getModel()
+        );
+    }
+    /**
      * Change the value of a string-valued parameter.
      * @param par [in] A string-valued parameter.
      * @param val [in] A new value for the string-valued parameter.
Index: src/main/java/com/alibaba/damo/mindopt/MdoEnv.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/alibaba/damo/mindopt/MdoEnv.java b/src/main/java/com/alibaba/damo/mindopt/MdoEnv.java
new file mode 100644
--- /dev/null	(revision 01dda60bc6d873d2b2db3401dc7829a6b6e0a2fd)
+++ b/src/main/java/com/alibaba/damo/mindopt/MdoEnv.java	(revision 01dda60bc6d873d2b2db3401dc7829a6b6e0a2fd)
@@ -0,0 +1,46 @@
+package com.alibaba.damo.mindopt;
+
+import com.alibaba.damo.mindopt.impl.MdoNativeEnv;
+
+import java.lang.reflect.Constructor;
+
+public class MdoEnv {
+    MdoNativeEnv env = new MdoNativeEnv();
+    boolean freed = false;
+
+    /**
+     * Mindopt environment constructor
+     */
+    public MdoEnv() {
+        env.createEnv();
+    }
+
+    /**
+     * Create model through environment object(recommended)
+     * @return MdoModel object
+     */
+    public MdoModel createModel() {
+        Constructor<MdoModel> constructor = null;
+        try {
+            constructor = MdoModel.class.getDeclaredConstructor(MdoEnv.class);
+            constructor.setAccessible(true);
+            return constructor.newInstance(this);
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * Mindopt environment releaser
+     */
+    public void free() {
+        if (!freed) {
+            freed = true;
+            env.freeEnv();
+        }
+    }
+
+    protected void finalize() throws MdoException {
+        free();
+    }
+}
Index: src/main/java/com/alibaba/damo/mindopt/MdoExprQuad.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/alibaba/damo/mindopt/MdoExprQuad.java b/src/main/java/com/alibaba/damo/mindopt/MdoExprQuad.java
new file mode 100644
--- /dev/null	(revision 2e14e6810b34cc3f4787fc485ab6f0f11afc15ef)
+++ b/src/main/java/com/alibaba/damo/mindopt/MdoExprQuad.java	(revision 2e14e6810b34cc3f4787fc485ab6f0f11afc15ef)
@@ -0,0 +1,386 @@
+/**
+ * Copyright 1999-2021 Alibaba Cloud All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.alibaba.damo.mindopt;
+
+import java.util.*;
+
+public class MdoExprQuad implements MdoExpr {
+    /**
+     * Data Structure
+     * A quadratic expression is represented as a linear expression, plus a list of quadratic terms.
+     */
+    MdoExprLinear linear = new MdoExprLinear();
+    private List<Map.Entry<Map.Entry<MdoVar, MdoVar>, Double>> quadTerms = new ArrayList<>();
+
+    private static class TripleComparator implements Comparator<Map.Entry<Map.Entry<MdoVar, MdoVar>, Double>> {
+        @Override
+        public int compare(Map.Entry<Map.Entry<MdoVar, MdoVar>, Double> l,
+                           Map.Entry<Map.Entry<MdoVar, MdoVar>, Double> r) {
+            Map.Entry<MdoVar, MdoVar> lVars = l.getKey();
+            Map.Entry<MdoVar, MdoVar> rVars = r.getKey();
+            int cmp = lVars.getKey().getIndex() - rVars.getKey().getIndex();
+            if (cmp != 0) return cmp;
+            return lVars.getValue().getIndex() - rVars.getValue().getIndex();
+        }
+    }
+
+    /**
+     * Default constructor
+     */
+    public MdoExprQuad() {}
+
+    /**
+     * Copy constructor
+     * @param another another linear expression
+     */
+    public MdoExprQuad(MdoExprQuad another) {
+        this.add(another);
+    }
+
+    public MdoExprQuad(MdoExprLinear le) {
+        this.linear = le;
+    }
+
+    /**
+     * Merge the same type
+     */
+    public void purge() {
+        this.linear.purge();
+        if (quadTerms.size() < 2) return;
+
+        List<Map.Entry<Map.Entry<MdoVar, MdoVar>, Double>> remap = new ArrayList<>();
+        for (Map.Entry<Map.Entry<MdoVar, MdoVar>, Double> entry : quadTerms) {
+            if (entry.getKey().getKey().getIndex() <= entry.getKey().getValue().getIndex()) {
+                remap.add(entry);
+            } else {
+                remap.add(new AbstractMap.SimpleEntry<>(
+                        new AbstractMap.SimpleEntry<>(entry.getKey().getValue(), entry.getKey().getKey()),
+                        entry.getValue()
+                ));
+            }
+        }
+        quadTerms = remap;
+        Collections.sort(quadTerms, new MdoExprQuad.TripleComparator());
+
+        List<Map.Entry<Map.Entry<MdoVar, MdoVar>, Double>> purged = new ArrayList<>();
+        purged.add(quadTerms.get(0));
+
+        Map.Entry<Map.Entry<MdoVar, MdoVar>, Double> surface = purged.get(0);
+
+        for (int i = 1; i < quadTerms.size(); i++) {
+            if (surface.getKey().getKey().equals(this.getVar1(i)) &&
+                    surface.getKey().getValue().equals(this.getVar2(i))) {
+                surface.setValue(surface.getValue() + getCoeff(i));
+            } else {
+                purged.add(quadTerms.get(i));
+                surface = purged.get(purged.size() - 1);
+            }
+        }
+        quadTerms = purged;
+    }
+
+    /**
+     * Add another linear expression
+     * @param rhs the linear expression to be added
+     */
+    public void add(MdoExprLinear rhs) {
+        this.linear.add(rhs);
+    }
+
+    /**
+     * Add another quadratic expression
+     * @param rhs the quadratic expression to be added
+     */
+    public void add(MdoExprQuad rhs) {
+        this.multAdd(1, rhs);
+    }
+
+    /**
+     * Add a constant multiple of another linear expression
+     * @param multiplier the multiplier constant
+     * @param rhs another linear expression
+     */
+    public void multAdd(double multiplier, MdoExprLinear rhs) {
+        this.linear.multAdd(multiplier, rhs);
+    }
+
+    /**
+     * Add a constant multiple of another quadratic expression
+     * @param multiplier the multiplier constant
+     * @param rhs another quadratic expression
+     */
+    public void multAdd(double multiplier, MdoExprQuad rhs) {
+        if (multiplier != 0d) {
+            this.linear.multAdd(multiplier, rhs.linear);
+
+            int size = rhs.size();
+            for (int i = 0; i < size; i++) {
+                this.addTerm(rhs.getCoeff(i) * multiplier, rhs.getVar1(i), rhs.getVar2(i));
+            }
+        }
+    }
+
+    /**
+     * Subtract another linear expression
+     * @param rhs another linear expression
+     */
+    public void subtract(MdoExprLinear rhs) {
+        this.linear.subtract(rhs);
+    }
+
+    /**
+     * Subtract another quadratic expression
+     * @param rhs another quadratic expression
+     */
+    public void subtract(MdoExprQuad rhs) {
+        this.multAdd(-1, rhs);
+    }
+
+    /**
+     * Add a single to this linear expression
+     * @param coeff the coefficient
+     * @param var the variable object
+     */
+    public void addTerm(double coeff, MdoVar var) {
+        this.linear.addTerm(coeff, var);
+    }
+
+    /**
+     * Add multiple terms to this linear expression
+     * @param coeffs the coefficient array
+     * @param vars the variable object array
+     */
+    public void addTerms(double[] coeffs, MdoVar[] vars) {
+        this.linear.addTerms(coeffs, vars, 0, vars.length);
+    }
+
+    /**
+     * Add multiple terms to this linear expression
+     * @param coeffs the coefficient array
+     * @param vars the variable object array
+     * @param start the offset of {@code coeffs} and {@code vars}
+     * @param len the number of terms to be added from arrays
+     */
+    public void addTerms(double[] coeffs, MdoVar[] vars, int start, int len) {
+        this.linear.addTerms(coeffs, vars, start, len);
+    }
+
+    /**
+     * Add a single to this quadratic expression
+     * @param coeff the coefficient
+     * @param var1 the variable object
+     * @param var2 the variable object
+     */
+    public void addTerm(double coeff, MdoVar var1, MdoVar var2) {
+        Map.Entry<MdoVar, MdoVar> key = new AbstractMap.SimpleEntry<>(var1, var2);
+        this.quadTerms.add(new AbstractMap.SimpleEntry<>(key, coeff));
+    }
+
+    /**
+     * Add multiple terms to this quadratic expression
+     * @param coeffs the coefficient array
+     * @param vars1 the variable object
+     * @param vars2 the variable object
+     */
+    public void addTerms(double[] coeffs, MdoVar[] vars1, MdoVar[] vars2) {
+        for (int i = 0; i < coeffs.length; i++) {
+            addTerm(coeffs[i], vars1[i], vars2[i]);
+        }
+    }
+
+    /**
+     * Add multiple terms to this quadratic expression
+     * @param coeffs the coefficient array
+     * @param vars1 the variable object array
+     * @param vars2 the variable object array
+     * @param start the offset of {@code coeffs} and {@code vars}
+     * @param len the number of terms to be added from arrays
+     */
+    public void addTerms(double[] coeffs, MdoVar[] vars1, MdoVar[] vars2, int start, int len) {
+        for (int i = start; i < start + len; i++) {
+            addTerm(coeffs[i], vars1[i], vars2[i]);
+        }
+    }
+
+    /**
+     * Get the first variable object with a single term from this quadratic expression
+     * @param index the term index
+     * @return the corresponding variable object
+     */
+    public MdoVar getVar1(int index) {
+        return this.quadTerms.get(index).getKey().getKey();
+    }
+
+    /**
+     * Get all the first variable object within array from this quadratic expression
+     * @return the corresponding variable object
+     */
+    public MdoVar[] getVars1() {
+        MdoVar[] vars = new MdoVar[this.size()];
+        for (int i = 0; i < this.size(); i++) {
+            vars[i] = this.getVar1(i);
+        }
+        return vars;
+    }
+
+    /**
+     * Get the second variable object with a single term from this quadratic expression
+     * @param index the term index
+     * @return the corresponding variable object
+     */
+    public MdoVar getVar2(int index) {
+        return this.quadTerms.get(index).getKey().getValue();
+    }
+
+    /**
+     * Get all the second variable object within array from this quadratic expression
+     * @return the corresponding variable object
+     */
+    public MdoVar[] getVars2() {
+        MdoVar[] vars = new MdoVar[this.size()];
+        for (int i = 0; i < this.size(); i++) {
+            vars[i] = this.getVar2(i);
+        }
+        return vars;
+    }
+
+    /**
+     * Get the coefficient with a single term from this quadratic expression
+     * @param index the term index
+     * @return the corresponding coefficient
+     */
+    public double getCoeff(int index) {
+        return this.quadTerms.get(index).getValue();
+    }
+
+    /**
+     * Get all the coefficient within array from this quadratic expression
+     * @return the corresponding coefficient
+     */
+    public double[] getCoeffs() {
+        double[] coeffs = new double[this.size()];
+        for (int i = 0; i < this.size(); i++) {
+            coeffs[i] = this.getCoeff(i);
+        }
+        return coeffs;
+    }
+
+    /**
+     * Get the linear expression associated with the quadratic expression
+     * @return the linear expression
+     */
+    public MdoExprLinear getLinear() {
+        return this.linear;
+    }
+
+    public MdoVar getLinearTerm(int index) {
+        return this.linear.getVar(index);
+    }
+
+    public Map.Entry<MdoVar, MdoVar> getQuadTerm(int index) {
+        return this.quadTerms.get(index).getKey();
+    }
+
+    public boolean removeTerm(MdoVar var) {
+        return this.linear.removeTerm(var);
+    }
+
+    /**
+     * Remove the quadratic term stored at index i of the expression
+     * @param index the term index
+     */
+    public void removeTerm(int index) {
+        this.quadTerms.remove(index);
+    }
+
+    /**
+     * Remove all terms associated with variable var from the quadratic expression
+     * @param var the variable object
+     * @return true for successful removal, false if no such term found
+     */
+    public boolean removeTerm(Map.Entry<MdoVar, MdoVar> var) {
+        boolean found = false;
+        ListIterator<Map.Entry<Map.Entry<MdoVar, MdoVar>, Double>> iter = quadTerms.listIterator();
+        while (iter.hasNext()) {
+            Map.Entry<MdoVar, MdoVar> it = iter.next().getKey();
+            if ((it.getKey().equals(var.getKey()) && it.getValue().equals(var.getValue())) ||
+                    (it.getKey().equals(var.getValue())  && it.getValue().equals(var.getKey()))
+            ) {
+                found = true;
+                iter.remove();
+            }
+        }
+        return found;
+    }
+
+    /**
+     * Get the constant part of this linear expression
+     * @return the constant value
+     */
+    public double getConstant() {
+        return this.linear.getConstant();
+    }
+
+    /**
+     * Set the constant part of this linear expression
+     * @param constant the constant value
+     */
+    public void addConstant(double constant) {
+        this.linear.addConstant(constant);
+    }
+
+    /**
+     * Add a value to the constant part of this linear expression
+     * @param constant the value to be added
+     */
+    public void setConstant(double constant) {
+        this.linear.setConstant(constant);
+    }
+
+    /**
+     * Remove all terms in this quadratic expression(also include linear express), and reset constant to zero
+     */
+    public void clear() {
+        this.linear.clear();
+        this.quadTerms.clear();
+    }
+
+    /**
+     * Size of the linear expression
+     * @return the number of terms
+     */
+    public int size() {
+        return this.quadTerms.size();
+    }
+
+    /**
+     * Test weather two quadratic expressions are the same
+     * @param rhs another quadratic expression to be tested
+     * @return true if two quadratic expressions are the same
+     */
+    public boolean equals(MdoExprQuad rhs) {
+        if (this.size() != rhs.size()) {
+            return false;
+        }
+        for (int i = 0; i < this.size(); i++) {
+            if (!this.getVar1(i).equals(rhs.getVar1(i)) || !this.getVar2(i).equals(rhs.getVar2(i)) || this.getCoeff(i) != rhs.getCoeff(i)) {
+                return false;
+            }
+        }
+        return this.linear.equals(rhs.linear);
+    }
+}
Index: src/main/java/com/alibaba/damo/mindopt/MdoModel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/alibaba/damo/mindopt/MdoModel.java b/src/main/java/com/alibaba/damo/mindopt/MdoModel.java
--- a/src/main/java/com/alibaba/damo/mindopt/MdoModel.java	(revision 34ac7d76b3f2aeea4e46af406b6d01ff6dc81f23)
+++ b/src/main/java/com/alibaba/damo/mindopt/MdoModel.java	(revision ce1a24e12f8193b9c421115cfcf00ab3d91f3152)
@@ -17,19 +17,21 @@
 package com.alibaba.damo.mindopt;
 
 
-import com.alibaba.damo.mindopt.impl.MdoMatrixImpl;
-import com.alibaba.damo.mindopt.impl.MemoryUtil;
+import com.alibaba.damo.mindopt.impl.*;
 import com.sun.jna.Callback;
+import com.sun.jna.Memory;
 import com.sun.jna.Native;
 import com.sun.jna.Pointer;
 
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
+
 /**
  *  This object implements the data structure to hold an optimization model.
  *
- *  Typical steps to to input a column into the optimization model are:
+ *  Typical steps to input a column into the optimization model are:
  *  <OL>
  *  <LI>Create a set of empty variable objects by calling MdoModel.addVar</LI>
  *  <LI>Specify the variable's lower bound, upper bound, and objective coefficients</LI>
@@ -38,137 +40,815 @@
  *  <LI>Optimize the problem by calling MdoModel.solveProb</LI>
  *  </OL>
  */
-public class MdoModel extends MdoMatrixImpl {
+public class MdoModel implements MdoProblem, MdoSolver {
+    protected MdoNativeModel model = new MdoNativeModel();
+    protected List<MdoVar> vars = new ArrayList<MdoVar>();
+    protected List<MdoCons> conss = new ArrayList<MdoCons>();
+    protected boolean freed = false;
     /**
-     * This class represents the status of a specified remote task
+     * Default constructor
+     * @deprecated Constructor of MdoModel is deprecated since 0.19, use <code>MdoEnv.createModel()</code> instead.
      */
-    public enum RemoteTaskStatus {
-        /**
-         * This task is prepared to be scheduled
-         */
-        Submitted,
-        /**
-         * This task is now in solving phase
-         */
-        Solving,
-        /**
-         * This task is canceled
-         */
-        Canceled,
-        /**
-         * This task is finished (OPTIMAL, INFEASIBLE ...)
-         */
-        Finished,
-        /**
-         * This task is failed
-         */
-        Failed
+    @Deprecated
+    public MdoModel() {
+        model.createMdl();
     }
+
+    private MdoModel(MdoEnv env) {
+        env.env.createMdlWithEnv(model);
+    }
+
+    private char inverse(char sense) {
+        if (sense == Mdo.LESS_EQUAL) {
+            return Mdo.GREATER_EQUAL;
+        } else if (sense == Mdo.GREATER_EQUAL) {
+            return Mdo.LESS_EQUAL;
+        } else {
+            return Mdo.EQUAL;
+        }
+    }
+
+    protected void syncData(boolean syncConss, boolean syncVars) {
+        if (syncConss) {
+            this.conss.clear();
+            for (int i = 0; i < model.getNumRows(); i++) {
+                this.conss.add(new MdoConsImpl(this, i));
+            }
+        }
+        if (syncVars) {
+            this.vars.clear();
+            for (int i = 0; i < model.getNumCols(); i++) {
+                this.vars.add(new MdoVarImpl(this, i));
+            }
+        }
+    }
+
+    @Override
+    public MdoVar addVar(double lb, double ub, double obj, boolean isInteger, String name) {
+        return addVar(lb, ub, obj, isInteger, null, null, name);
+    }
+
+    @Override
+    public MdoVar addVar(double lb, double ub, double obj, boolean isInteger, MdoCol col, String name) {
+        if (col == null) {
+            return this.addVar(lb, ub, obj, isInteger, null, null, name);
+        } else {
+            MdoCons[] conss = new MdoCons[col.size()];
+            double[] coeffs = new double[col.size()];
+
+            for(int i = 0; i < col.size(); ++i) {
+                conss[i] = col.getCons(i);
+                coeffs[i] = col.getCoeff(i);
+            }
+            return this.addVar(lb, ub, obj, isInteger, conss, coeffs, name);
+        }
+    }
+
+    @Override
+    public MdoVar addVar(double lb, double ub, double obj, boolean isInteger, MdoCons[] conss, double[] coeffs, String name) {
+        int code;
+        Pointer pName = MemoryUtil.charArray(name);
+        if (conss == null || conss.length == 0) {
+            code = model.addCol(
+                    lb, ub, obj, 0,
+                    Pointer.NULL, Pointer.NULL,
+                    pName, isInteger ? 1 : 0
+            );
+        } else {
+            int size = conss.length;
+            Pointer indices = MemoryUtil.intArray(size);
+            Pointer values = MemoryUtil.doubleArray(size);
+            for (int i = 0; i < size; i++) {
+                MemoryUtil.setInt(indices, i, conss[i].getIndex());
+                if (coeffs == null || coeffs.length <= i) {
+                    MemoryUtil.setDouble(values, i, 1);
+                } else {
+                    MemoryUtil.setDouble(values, i, coeffs[i]);
+                }
+            }
+            code = model.addCol(lb, ub, obj, size, indices, values, pName, isInteger ? 1 : 0);
+        }
+        MdoResult.checkResult(code);
+        MdoVar var = new MdoVarImpl(this, vars.size());
+        vars.add(var);
+        return var;
+    }
+
+    @Override
+    public MdoVar[] addVars(int count, boolean isInteger) {
+        MdoVar[] vars = new MdoVar[count];
+        for (int i = 0; i < count; i++) {
+            vars[i] = this.addVar(0, Mdo.INFINITY, 0, isInteger, null);
+        }
+        return vars;
+    }
+
+    @Override
+    public MdoVar[] addVars(double[] lbs, double[] ubs, double[] objs, boolean[] areIntegers, String[] names) {
+        int size = lbs.length;
+        return this.addVars(lbs, ubs, objs, areIntegers, names, 0, size);
+    }
+
+    @Override
+    public MdoVar[] addVars(double[] lbs, double[] ubs, double[] objs, boolean[] areIntegers, String[] names, int start, int len) {
+        if (len < 0) {
+            return null;
+        } else if (len == 0) {
+            return new MdoVar[0];
+        }
+
+        MdoVar[] result = new MdoVar[len];
+        for (int i = start; i < start + len; i++) {
+            result[i - start] = this.addVar(lbs[i], ubs[i], objs[i], areIntegers[i], names == null ? null : names[i]);
+        }
+
+        return result;
+    }
+
+    @Override
+    public MdoVar[] addVars(double[] lbs, double[] ubs, double[] objs, boolean[] areIntegers, MdoCol[] cols, String[] names) {
+        if (lbs.length == 0) {
+            return new MdoVar[0];
+        }
+        MdoVar[] result = new MdoVar[lbs.length];
+        for (int i = 0; i < lbs.length; i++) {
+            result[i] = this.addVar(lbs[i], ubs[i], objs[i], areIntegers[i], cols[i] , names == null ? null : names[i]);
+        }
+        return result;
+    }
+
+    @Override
+    public MdoCons addCons(MdoExprLinear lhs, char sense, MdoExprLinear rhs, String name) {
+        MdoExprLinear expr = new MdoExprLinear(lhs);
+        expr.multAdd(-1, rhs);
+        return this.addCons(expr, sense, 0, name);
+    }
+
+    @Override
+    public MdoCons addCons(MdoVar lhs, char sense, MdoVar rhs, String name) {
+        MdoExprLinear expr = new MdoExprLinear();
+        expr.addTerm(1, lhs);
+        expr.addTerm(-1, rhs);
+        return this.addCons(expr, sense, 0, name);
+    }
+
+    @Override
+    public MdoCons addCons(MdoExprLinear lhs, char sense, MdoVar rhs, String name) {
+        MdoExprLinear expr = new MdoExprLinear(lhs);
+        expr.addTerm(-1, rhs);
+        return this.addCons(expr, sense, 0, name);
+    }
+
+    @Override
+    public MdoCons addCons(MdoVar lhs, char sense, MdoExprLinear rhs, String name) {
+        return this.addCons(rhs, inverse(sense), lhs, name);
+    }
+
+    @Override
+    public MdoCons addCons(double lhs, char sense, MdoExprLinear rhs, String name) {
+        return this.addCons(rhs, inverse(sense), lhs, name);
+    }
+
+    @Override
+    public MdoCons addCons(MdoVar lhs, char sense, double rhs, String name) {
+        MdoExprLinear expr = new MdoExprLinear();
+        expr.addTerm(1, lhs);
+        return this.addCons(expr, sense, rhs, name);
+    }
+
+    @Override
+    public MdoCons addCons(double lhs, char sense, MdoVar rhs, String name) {
+        return this.addCons(rhs, inverse(sense), lhs, name);
+    }
+
+    @Override
+    public MdoCons addCons(MdoExprLinear lhs, char sense, double rhs, String name) {
+        MdoExprLinear expr = new MdoExprLinear(lhs);
+
+        if (rhs > Mdo.NEGATIVE_INFINITY && rhs < Mdo.INFINITY) {
+            rhs -= expr.getConstant();
+        }
+
+        expr.purge();
+        int size = expr.size();
+        Pointer indices = MemoryUtil.intArray(size);
+        Pointer values = MemoryUtil.doubleArray(size);
+        Pointer pName = MemoryUtil.charArray(name);
+
+        for (int i = 0; i < expr.size(); i++) {
+            MemoryUtil.setInt(indices, i, expr.getVar(i).getIndex());
+            MemoryUtil.setDouble(values, i, expr.getCoeff(i));
+        }
+
+        double l = rhs;
+        double r = rhs;
+
+        if (sense == Mdo.LESS_EQUAL) {
+            l = Mdo.NEGATIVE_INFINITY;
+        } else if (sense == Mdo.GREATER_EQUAL) {
+            r = Mdo.INFINITY;
+        }
+
+        int code = model.addRow(l, r, size, indices, values, pName);
+        MdoResult.checkResult(code);
+
+        MdoCons cons = new MdoConsImpl(this, conss.size());
+        conss.add(cons);
+        return cons;
+    }
+
+    @Override
+    public MdoCons addRange(MdoExprLinear expr, double lower, double upper, String name) {
+        MdoExprLinear expr1 = new MdoExprLinear(expr);
+
+        if (upper > Mdo.NEGATIVE_INFINITY && upper < Mdo.INFINITY) {
+            upper -= expr.getConstant();
+        }
+
+        if (lower > Mdo.NEGATIVE_INFINITY && lower < Mdo.INFINITY) {
+            lower -= expr.getConstant();
+        }
+
+        expr1.purge();
+        int size = expr1.size();
+        Pointer indices = MemoryUtil.intArray(size);
+        Pointer values = MemoryUtil.doubleArray(size);
+        Pointer pName = MemoryUtil.charArray(name);
+
+        for (int i = 0; i < expr1.size(); i++) {
+            MemoryUtil.setInt(indices, i, expr1.getVar(i).getIndex());
+            MemoryUtil.setDouble(values, i, expr1.getCoeff(i));
+        }
 
-    public interface MdoRemoteTask {
-        /**
-         * Get the remote task status code
-         * @return the remote task status code
-         */
-        int getStatusCode();
+        int code = model.addRow(lower, upper, size, indices, values, pName);
+        MdoResult.checkResult(code);
 
-        /**
-         * Get the remote task status (OPTIMAL, INFEASIBLE ...)
-         * @return the remote task status (OPTIMAL, INFEASIBLE ...)
-         */
-        MdoStatus getStatus();
+        MdoCons cons = new MdoConsImpl(this, conss.size());
+        conss.add(cons);
+        return cons;
+    }
 
-        /**
-         * Get the remote task result code
-         * @return the remote task status code
-         */
-        int getResultCode();
+    @Override
+    public MdoCons[] addConss(int count) {
+        MdoCons conss[] = new MdoCons[count];
+        for (int i = 0; i < count; i++) {
+            int code = model.addRow(Mdo.NEGATIVE_INFINITY, 0, 0, Pointer.NULL, Pointer.NULL, Pointer.NULL);
+            MdoResult.checkResult(code);
 
-        /**
-         * Get the remote task result status (MDO_OK ...)
-         * @return the remote task result status (MDO_OK ...)
-         */
-        MdoResult getResult();
+            MdoCons cons = new MdoConsImpl(this, this.conss.size());
+            this.conss.add(cons);
+            conss[i] = cons;
+        }
+        return conss;
+    }
 
-        /**
-         * Check weather remote task has a solution
-         * @return weather remote task has a solution
-         */
-        boolean hasSolution();
+    @Override
+    public MdoCons[] addConss(MdoExprLinear[] lhss, char[] senses, double[] rhss, String[] names) {
+        MdoCons[] conss = new MdoCons[lhss.length];
+        for (int i = 0; i < lhss.length; i++) {
+            conss[i] = this.addCons(lhss[i], senses[i], rhss[i], names == null ? null : names[i]);
+        }
+        return conss;
+    }
 
-        /**
-         * Get remote task job status (Submitted, Solving...)
-         * @return remote task job status (Submitted, Solving...)
-         */
-        RemoteTaskStatus getRemoteTaskStatus();
+    @Override
+    public MdoCons[] addConss(MdoExprLinear[] lhss, char[] senses, double[] rhss, String[] names, int start, int len) {
+        MdoCons[] conss = new MdoCons[len];
+        for (int i = start; i < start + len; i++) {
+            conss[i - start] = this.addCons(lhss[i], senses[i], rhss[i], names == null ? null : names[i]);
+        }
+        return conss;
     }
 
-    /**
-     * Irreducible Inconsistent Subsystem
-     */
-    public interface IIS {
-        /**
-         * Get all constraints involved in an IIS
-         * @return all constraints involved in an IIS
-         */
-        List<Integer> getRowIndices();
+    @Override
+    public MdoCons[] addRanges(MdoExprLinear[] exprs, double[] lowers, double[] uppers, String[] names) {
+        MdoCons[] conss = new MdoCons[exprs.length];
+        for (int i = 0; i < exprs.length; i++) {
+            conss[i] = this.addRange(exprs[i], lowers[i], uppers[i], names == null ? null : names[i]);
+        }
+        return conss;
+    }
+
+    @Override
+    public MdoVar getVar(int j) {
+        if (j < 0 || j >= vars.size()) {
+            MdoResult.checkResult(MdoResult.MDO_MODEL_INVALID_COL_IDX.getCode());
+        }
+        return vars.get(j);
+    }
+
+    @Override
+    public MdoCons getCons(int i) {
+        if (i < 0 || i >= conss.size()) {
+            MdoResult.checkResult(MdoResult.MDO_MODEL_INVALID_ROW_IDX.getCode());
+        }
+        return conss.get(i);
+    }
+
+    @Override
+    public MdoVar getVar(String name) {
+        int j = model.getColIndex(MemoryUtil.charArray(name));
+        if (j < 0) {
+            MdoResult.checkResult(MdoResult.MDO_MODEL_INVALID_COL_NAME.getCode());
+        }
+        return vars.get(j);
+    }
 
-        /**
-         * Get all variables involved in an IIS
-         * @return all variables involved in an IIS
-         */
-        List<Integer> getColIndices();
+    @Override
+    public MdoCons getCons(String name) {
+        int i = model.getRowIndex(MemoryUtil.charArray(name));
+        if (i < 0) {
+            MdoResult.checkResult(MdoResult.MDO_MODEL_INVALID_ROW_NAME.getCode());
+        }
+        return conss.get(i);
+    }
+
+    @Override
+    public MdoVar[] getVars() {
+        return vars.toArray(new MdoVar[0]);
+    }
+
+    @Override
+    public MdoCons[] getConss() {
+        return conss.toArray(new MdoCons[0]);
+    }
+
+    @Override
+    public void deleteVars(MdoVar[] vars) {
+        List<Integer> indices = new ArrayList<Integer>();
+        for (MdoVar var : vars) {
+            indices.add(var.getIndex());
+        }
+
+        Collections.sort(indices);
+        int len = 1;
+        for (int i = 1; i < indices.size(); i++) {
+            if (indices.get(i).intValue() != indices.get(i - 1)) {
+                len++;
+            }
+        }
+
+        Pointer pIndices = MemoryUtil.intArray(len);
+        int offset = 0;
+
+        MemoryUtil.setInt(pIndices, offset++, indices.get(0));
+        for (int i = 1; i < indices.size(); i++) {
+            if (indices.get(i).intValue() != indices.get(i - 1)) {
+                MemoryUtil.setInt(pIndices, offset++, indices.get(i));
+            }
+        }
+
+        MdoResult.checkResult(model.deleteCols(len, pIndices));
+        syncData(false, true);
     }
 
-    /**
-     * Log callback
-     */
-    public interface LogCallback {
-        /**
-         * log message
-         * @param msg the message
-         */
-        void log(String msg);
-    }
+    @Override
+    public void deleteConss(MdoCons[] conss) {
+        List<Integer> indices = new ArrayList<Integer>();
+        for (MdoCons cons : conss) {
+            indices.add(cons.getIndex());
+        }
 
-    /**
-     * Load problem to model from file.
-     *
-     * Note that the type of the inputted format is determined by the file suffix, valid suffixes are `.mps(.bz2/.gz)` or `.lp(.bz2/.gz)`
-     * @param filename the file name
-     */
+        Collections.sort(indices);
+        int len = 1;
+        for (int i = 1; i < indices.size(); i++) {
+            if (indices.get(i).intValue() != indices.get(i - 1)) {
+                len++;
+            }
+        }
+
+        Pointer pIndices = MemoryUtil.intArray(len);
+        int offset = 0;
+
+        MemoryUtil.setInt(pIndices, offset++, indices.get(0));
+        for (int i = 1; i < indices.size(); i++) {
+            if (indices.get(i).intValue() != indices.get(i - 1)) {
+                MemoryUtil.setInt(pIndices, offset++, indices.get(i));
+            }
+        }
+
+        MdoResult.checkResult(model.deleteRows(len, pIndices));
+        syncData(true, false);
+    }
+
+
+    @Override
+    public MdoCol getCol(MdoVar var) {
+        int j = var.getIndex();
+        Pointer realSize = MemoryUtil.intByReference();
+        Pointer colIndices = MemoryUtil.intArray(1);
+        MemoryUtil.setInt(colIndices, 0, j);
+
+        MdoResult.checkResult(model.getCols(1, colIndices, Pointer.NULL, Pointer.NULL, Pointer.NULL, 0, realSize));
+        MdoCol col = new MdoCol();
+        if (realSize.getInt(0) > 0) {
+            Pointer bgn = MemoryUtil.intArray(2);
+            Pointer indices = MemoryUtil.intArray(realSize.getInt(0));
+            Pointer values = MemoryUtil.doubleArray(realSize.getInt(0));
+            MdoResult.checkResult(model.getCols(1, colIndices, bgn, indices, values, realSize.getInt(0), realSize));
+            for (int i = 0; i < realSize.getInt(0); i++) {
+                double coeff = MemoryUtil.getDouble(values, i);
+                MdoCons cons = conss.get(MemoryUtil.getInt(indices, i));
+                col.addTerm(coeff, cons);
+            }
+        }
+        return col;
+    }
+
+    @Override
+    public MdoExprLinear getExprLinear(MdoCons cons) {
+        int i = cons.getIndex();
+        Pointer realSize = MemoryUtil.intByReference();
+        Pointer rowIndices = MemoryUtil.intArray(1);
+        MemoryUtil.setInt(rowIndices, 0, i);
+
+        MdoResult.checkResult(model.getRows(1, rowIndices, Pointer.NULL, Pointer.NULL, Pointer.NULL, 0, realSize));
+        MdoExprLinear expr = new MdoExprLinear();
+        if (realSize.getInt(0) > 0) {
+            Pointer bgn = MemoryUtil.intArray(2);
+            Pointer indices = MemoryUtil.intArray(realSize.getInt(0));
+            Pointer values = MemoryUtil.doubleArray(realSize.getInt(0));
+            MdoResult.checkResult(model.getRows(1, rowIndices, bgn, indices, values, realSize.getInt(0), realSize));
+            for (int j = 0; j < realSize.getInt(0); j++) {
+                double coeff = MemoryUtil.getDouble(values, j);
+                MdoVar var = vars.get(MemoryUtil.getInt(indices, j));
+                expr.addTerm(coeff, var);
+            }
+        }
+        return expr;
+    }
+
+    @Override
+    public boolean isMinObjSense() {
+        return model.isMinObjSense() != 0;
+    }
+
+    @Override
+    public boolean isMaxObjSense() {
+        return model.isMaxObjSense() != 0;
+    }
+
+    @Override
+    public void setMinObjSense() {
+        model.setMinObjSense();
+    }
+
+    @Override
+    public void setMaxObjSense() {
+        model.setMaxObjSense();
+    }
+
+    @Override
+    public double getObjOffset() {
+        return model.getObjOffset();
+    }
+
+    @Override
+    public void setObjOffset(double objFix) {
+        model.setObjOffset(objFix);
+    }
+
+    @Override
+    public double[] getObjs(MdoVar[] vars) {
+        return getRealAttrVars(Mdo.REAL_ATTR_OBJ, vars);
+    }
+
+    @Override
+    public void setObjs(MdoVar[] vars, double[] vals) {
+        setRealAttrVars(Mdo.REAL_ATTR_OBJ, vars, vals);
+    }
+
+    @Override
+    public double[] getElements(MdoCons[] conss, MdoVar[] vars) {
+        Pointer values = MemoryUtil.doubleArray(conss.length);
+        Pointer rowIndices = MemoryUtil.intArray(conss.length);
+        Pointer colIndices = MemoryUtil.intArray(conss.length);
+
+        for (int i = 0; i < conss.length; i++) {
+            MemoryUtil.setInt(rowIndices, i, conss[i].getIndex());
+            MemoryUtil.setInt(colIndices, i, vars[i].getIndex());
+        }
+
+        MdoResult.checkResult(model.getElements(conss.length, rowIndices, colIndices, values));
+        return values.getDoubleArray(0, conss.length);
+    }
+
+    @Override
+    public void setElements(MdoCons[] conss, MdoVar[] vars, double[] values) {
+        Pointer pValues = MemoryUtil.doubleArray(conss.length);
+        Pointer rowIndices = MemoryUtil.intArray(conss.length);
+        Pointer colIndices = MemoryUtil.intArray(conss.length);
+
+        for (int i = 0; i < conss.length; i++) {
+            MemoryUtil.setInt(rowIndices, i, conss[i].getIndex());
+            MemoryUtil.setInt(colIndices, i, vars[i].getIndex());
+            MemoryUtil.setDouble(pValues, i, values[i]);
+        }
+
+        MdoResult.checkResult(model.setElements(conss.length, rowIndices, colIndices, pValues));
+    }
+
+    @Override
+    public void deleteElements(MdoCons[] conss, MdoVar[] vars) {
+        Pointer rowIndices = MemoryUtil.intArray(conss.length);
+        Pointer colIndices = MemoryUtil.intArray(conss.length);
+
+        for (int i = 0; i < conss.length; i++) {
+            MemoryUtil.setInt(rowIndices, i, conss[i].getIndex());
+            MemoryUtil.setInt(colIndices, i, vars[i].getIndex());
+        }
+
+        MdoResult.checkResult(model.deleteElements(conss.length, rowIndices, colIndices));
+    }
+
+    @Override
+    public void deleteAllElements() {
+        MdoResult.checkResult(model.deleteAllElements());
+    }
+
+    @Override
+    public double[] getQuadraticElements(MdoVar[] vars1, MdoVar[] vars2) {
+        Pointer values = MemoryUtil.doubleArray(vars1.length);
+        Pointer colIndices1 = MemoryUtil.intArray(vars1.length);
+        Pointer colIndices2 = MemoryUtil.intArray(vars1.length);
+
+        for (int i = 0; i < vars1.length; i++) {
+            MemoryUtil.setInt(colIndices1, i, vars1[i].getIndex());
+            MemoryUtil.setInt(colIndices2, i, vars2[i].getIndex());
+        }
+
+        MdoResult.checkResult(model.getQuadraticElements(vars1.length, colIndices1, colIndices2, values));
+        return values.getDoubleArray(0, vars1.length);
+    }
+
+    @Override
+    public void setQuadraticElements(MdoVar[] vars1, MdoVar[] vars2, double[] values) {
+        Pointer pValues = MemoryUtil.doubleArray(vars1.length);
+        Pointer colIndices1 = MemoryUtil.intArray(vars1.length);
+        Pointer colIndices2 = MemoryUtil.intArray(vars1.length);
+
+        for (int i = 0; i < vars1.length; i++) {
+            MemoryUtil.setInt(colIndices1, i, vars1[i].getIndex());
+            MemoryUtil.setInt(colIndices2, i, vars2[i].getIndex());
+            MemoryUtil.setDouble(pValues, i, values[i]);
+        }
+
+        MdoResult.checkResult(model.setQuadraticElements(vars1.length, colIndices1, colIndices2, pValues));
+    }
+
+    @Override
+    public void deleteQuadraticElements(MdoVar[] vars1, MdoVar[] vars2) {
+        Pointer colIndices1 = MemoryUtil.intArray(vars1.length);
+        Pointer colIndices2 = MemoryUtil.intArray(vars1.length);
+
+        for (int i = 0; i < vars1.length; i++) {
+            MemoryUtil.setInt(colIndices1, i, vars1[i].getIndex());
+            MemoryUtil.setInt(colIndices2, i, vars2[i].getIndex());
+        }
+
+        MdoResult.checkResult(model.deleteQuadraticElements(vars1.length, colIndices1, colIndices2));
+    }
+
+    @Override
+    public void deleteAllQuadraticElements() {
+        MdoResult.checkResult(model.deleteAllQuadraticElements());
+    }
+
+    @Override
+    public void setStrAttrIndex(String att, int index, String val) {
+        MdoResult.checkResult(model.setStrAttrIndex(MemoryUtil.charArray(att), index, MemoryUtil.charArray(val)));
+    }
+
+    @Override
+    public String getStrAttrIndex(String att, int index) {
+        Pointer buffer = new Memory(Mdo.MAX_NATIVE_STR_LEN);
+        MdoResult.checkResult(model.getStrAttrIndex(MemoryUtil.charArray(att), index, Mdo.MAX_NATIVE_STR_LEN, buffer));
+        return Native.toString(buffer.getByteArray(0, Mdo.MAX_NATIVE_STR_LEN));
+    }
+
+    @Override
+    public void setIntAttrIndex(String att, int index, int val) {
+        MdoResult.checkResult(model.setIntAttrIndex(MemoryUtil.charArray(att), index, val));
+    }
+
+    @Override
+    public int getIntAttrIndex(String att, int index) {
+        Pointer n = MemoryUtil.intByReference();
+        MdoResult.checkResult(model.getIntAttrIndex(MemoryUtil.charArray(att), index, n));
+        return n.getInt(0);
+    }
+
+    @Override
+    public void setRealAttrIndex(String att, int index, double val) {
+        MdoResult.checkResult(model.setRealAttrIndex(MemoryUtil.charArray(att), index, val));
+    }
+
+    @Override
+    public double getRealAttrIndex(String att, int index) {
+        Pointer d = MemoryUtil.doubleByReference();
+        MdoResult.checkResult(model.getRealAttrIndex(MemoryUtil.charArray(att), index, d));
+        return d.getDouble(0);
+    }
+
+    @Override
+    public void setIntAttrArray(String att, int start, int len, int[] val) {
+        MdoResult.checkResult(model.setIntAttrArray(MemoryUtil.charArray(att), start, len, MemoryUtil.intArray(val)));
+    }
+
+    @Override
+    public int[] getIntAttrArray(String att, int start, int len) {
+        Pointer val = MemoryUtil.intArray(len);
+        MdoResult.checkResult(model.getIntAttrArray(MemoryUtil.charArray(att), start, len, val));
+        return val.getIntArray(0, len);
+    }
+
+    @Override
+    public void setRealAttrArray(String att, int start, int len, double[] val) {
+        MdoResult.checkResult(model.setRealAttrArray(MemoryUtil.charArray(att), start, len, MemoryUtil.doubleArray(val)));
+    }
+
+    @Override
+    public double[] getRealAttrArray(String att, int start, int len) {
+        Pointer val = MemoryUtil.doubleArray(len);
+        MdoResult.checkResult(model.getRealAttrArray(MemoryUtil.charArray(att), start, len, val));
+        return val.getDoubleArray(0, len);
+    }
+
+    @Override
+    public void setIntAttrVars(String att, MdoVar[] vars, int[] vals) {
+        for (int i = 0; i < vars.length; i++) {
+            MdoVar var = vars[i];
+            setIntAttrIndex(att, var.getIndex(), vals[i]);
+        }
+    }
+
+    @Override
+    public int[] getIntAttrVars(String att, MdoVar[] vars) {
+        int[] vals = new int[vars.length];
+        for (int i = 0; i < vars.length; i++) {
+            MdoVar var = vars[i];
+            vals[i] = getIntAttrIndex(att, var.getIndex());
+        }
+        return vals;
+    }
+
+    @Override
+    public void setRealAttrVars(String att, MdoVar[] vars, double[] vals) {
+        for (int i = 0; i < vars.length; i++) {
+            MdoVar var = vars[i];
+            setRealAttrIndex(att, var.getIndex(), vals[i]);
+        }
+    }
+
+    @Override
+    public double[] getRealAttrVars(String att, MdoVar[] vars) {
+        double[] vals = new double[vars.length];
+        for (int i = 0; i < vars.length; i++) {
+            MdoVar var = vars[i];
+            vals[i] = getRealAttrIndex(att, var.getIndex());
+        }
+        return vals;
+    }
+
+    @Override
+    public void setIntAttrConss(String att, MdoCons[] conss, int[] vals) {
+        for (int i = 0; i < conss.length; i++) {
+            MdoCons cons = conss[i];
+            setIntAttrIndex(att, cons.getIndex(), vals[i]);
+        }
+    }
+
+    @Override
+    public int[] getIntAttrConss(String att, MdoCons[] conss) {
+        int[] vals = new int[conss.length];
+        for (int i = 0; i < conss.length; i++) {
+            MdoCons cons = conss[i];
+            vals[i] = getIntAttrIndex(att, cons.getIndex());
+        }
+        return vals;
+    }
+
+    @Override
+    public void setRealAttrConss(String att, MdoCons[] conss, double[] vals) {
+        for (int i = 0; i < conss.length; i++) {
+            MdoCons cons = conss[i];
+            setRealAttrIndex(att, cons.getIndex(), vals[i]);
+        }
+    }
+
+    @Override
+    public double[] getRealAttrConss(String att, MdoCons[] conss) {
+        double[] vals = new double[conss.length];
+        for (int i = 0; i < conss.length; i++) {
+            MdoCons cons = conss[i];
+            vals[i] = getRealAttrIndex(att, cons.getIndex());
+        }
+        return vals;
+    }
+
+    @Override
+    public void setIntAttr(String att, int val) {
+        MdoResult.checkResult(model.setIntAttr(MemoryUtil.charArray(att), val));
+    }
+
+    @Override
+    public int getIntAttr(String att) {
+        Pointer val = MemoryUtil.intByReference();
+        MdoResult.checkResult(model.getIntAttr(MemoryUtil.charArray(att), val));
+        return val.getInt(0);
+    }
+
+    @Override
+    public void setRealAttr(String att, double val) {
+        MdoResult.checkResult(model.setRealAttr(MemoryUtil.charArray(att), val));
+    }
+
+    @Override
+    public double getRealAttr(String att) {
+        Pointer val = MemoryUtil.doubleByReference();
+        MdoResult.checkResult(model.getRealAttr(MemoryUtil.charArray(att), val));
+        return val.getDouble(0);
+    }
+
+    @Override
+    public void setStrAttr(String att, String val) {
+        MdoResult.checkResult(model.setStrAttr(MemoryUtil.charArray(att), MemoryUtil.charArray(val)));
+    }
+
+    @Override
+    public String getStrAttr(String att) {
+        Pointer buffer = new Memory(Mdo.MAX_NATIVE_STR_LEN);
+        MdoResult.checkResult(model.getStrAttr(MemoryUtil.charArray(att), Mdo.MAX_NATIVE_STR_LEN, buffer));
+        return Native.toString(buffer.getByteArray(0, Mdo.MAX_NATIVE_STR_LEN));
+    }
+
+    @Override
+    public void setStrParam(String par, String val) {
+        MdoResult.checkResult(model.setStrParam(MemoryUtil.charArray(par), MemoryUtil.charArray(val)));
+    }
+
+    @Override
+    public String getStrParam(String par) {
+        Pointer val = new Memory(Mdo.MAX_NATIVE_STR_LEN);
+        MdoResult.checkResult(model.getStrParam(MemoryUtil.charArray(par), Mdo.MAX_NATIVE_STR_LEN, val));
+        return Native.toString(val.getByteArray(0, Mdo.MAX_NATIVE_STR_LEN));
+    }
+
+    @Override
+    public void setIntParam(String par, int val) {
+        MdoResult.checkResult(model.setIntParam(MemoryUtil.charArray(par), val));
+    }
+
+    @Override
+    public int getIntParam(String par) {
+        Pointer val = MemoryUtil.intByReference();
+        MdoResult.checkResult(model.getIntParam(MemoryUtil.charArray(par), val));
+        return val.getInt(0);
+    }
+
+    @Override
+    public void setRealParam(String par, double val) {
+        MdoResult.checkResult(model.setRealParam(MemoryUtil.charArray(par), val));
+    }
+
+    @Override
+    public double getRealParam(String par) {
+        Pointer val = MemoryUtil.doubleByReference();
+        MdoResult.checkResult(model.getRealParam(MemoryUtil.charArray(par), val));
+        return val.getDouble(0);
+    }
+
+    @Override
+    public void free() {
+        if (!freed) {
+            freed = true;
+            model.freeMdl();
+        }
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        super.finalize();
+        free();
+    }
+
+    @Override
     public void readProb(String filename) {
         MdoResult.checkResult(model.readProb(MemoryUtil.charArray(filename)));
         syncData(true, true);
     }
 
-    /**
-     * Write problem to file.
-     *
-     * Note that the type of the outputted format is determined by the file suffix, valid suffixes are `.mps(.bz2/.gz)` or `.lp(.bz2/.gz)`
-     * @param filename the file name
-     */
+    @Override
     public void writeProb(String filename) {
         MdoResult.checkResult(model.writeProb(MemoryUtil.charArray(filename)));
     }
 
-    /**
-     * Write solution to a file.
-     *
-     * Note that the format of the solution is determined by the file suffix, valid suffixes are `.sol` or `.bas`.
-     * @param filename the file name
-     */
+    @Override
     public void writeSoln(String filename) {
         MdoResult.checkResult(model.writeSoln(MemoryUtil.charArray(filename)));
     }
 
-    /**
-     * Load optimization model task from a file.
-     * @param filename the file name
-     * @param readModel a boolean flag that specifies if the model shall be loaded
-     * @param readParam a boolean flag that specifies if the parameters shall be loaded
-     * @param readSoln a boolean flag that specifies if the solution shall be loaded
-     */
+    @Override
     public void readTask(String filename, boolean readModel, boolean readParam, boolean readSoln) {
         MdoResult.checkResult(
                 model.readTask(
@@ -181,14 +861,7 @@
         }
     }
 
-
-    /**
-     * Write an optimization model task to a file
-     * @param filename the file name
-     * @param writeModel a boolean flag that specifies if the model shall be outputted
-     * @param writeParam a boolean flag that specifies if the parameters shall be outputted
-     * @param writeSoln a boolean flag that specifies if the solution shall be outputted
-     */
+    @Override
     public void writeTask(String filename, boolean writeModel, boolean writeParam, boolean writeSoln) {
         MdoResult.checkResult(
                 model.writeTask(
@@ -198,21 +871,14 @@
         );
     }
 
-    /**
-     * Submit an optimization model task to a remote server for optimization
-     * @return the remote task id
-     */
+    @Override
     public String submitTask() {
         Pointer id = MemoryUtil.nativeString();
         MdoResult.checkResult(model.submitTask(id));
         return Native.toString(id.getByteArray(0, Mdo.MAX_NATIVE_STR_LEN));
     }
 
-    /**
-     * Retrieve remote task status by its task id
-     * @param jobId the task id returned on task submission
-     * @return remote task status
-     */
+    @Override
     public MdoRemoteTask retrieveTask(String jobId) {
         final Pointer status = MemoryUtil.nativeString();
         final Pointer code = MemoryUtil.intByReference();
@@ -255,26 +921,17 @@
         };
     }
 
-    /**
-     * Print log to standard output or not
-     * @param flag a flag that specified if the log shall be printed out to screen or not
-     */
+    @Override
     public void setLogToConsole(boolean flag) {
         MdoResult.checkResult(model.setLogToConsole(flag ? 1 : 0));
     }
 
-    /**
-     * Redirect log to a file
-     * @param filename the file name
-     */
+    @Override
     public void setLogFile(String filename) {
         MdoResult.checkResult(model.setLogFile(MemoryUtil.charArray(filename)));
     }
 
-    /**
-     * Customize log output to a user-defined callback
-     * @param logCallback the log callback function wrapper class
-     */
+    @Override
     public void setLogCallback(final LogCallback logCallback) {
         Callback callback = new Callback() {
             public void invoke(String msg, Pointer userdata) {
@@ -284,54 +941,36 @@
         MdoResult.checkResult(model.setLogCallback(callback, Pointer.NULL));
     }
 
-    /**
-     * Solve the loaded optimization problem
-     */
+    @Override
     public void solveProb() {
         MdoResult.checkResult(model.solveProb());
     }
 
-    /**
-     * Display the current solver results
-     */
+    @Override
     public void displayResult() {
         model.displayResults();
     }
 
-    /**
-     * Get the current solver status
-     * @return the solver status
-     */
+    @Override
     public MdoStatus getStatus() {
         return MdoStatus.fromCode(model.getStatus());
     }
 
-    /**
-     * Explain the solver status enumeration
-     * @param status the status to explain
-     * @return a string that holds the explanation of the solver status enumeration
-     */
+    @Override
     public String explainStatus(MdoStatus status) {
         Pointer val = MemoryUtil.nativeString();
         model.explainStatus(status.getCode(), val);
         return Native.toString(val.getByteArray(0, Mdo.MAX_NATIVE_STR_LEN));
     }
 
-    /**
-     * Explain the solver result enumeration
-     * @param result the result to explain
-     * @return a string that holds the explanation of the solver result enumeration
-     */
+    @Override
     public String explainResult(MdoResult result) {
         Pointer val = MemoryUtil.nativeString();
         model.explainResult(result.getCode(), val);
         return Native.toString(val.getByteArray(0, Mdo.MAX_NATIVE_STR_LEN));
     }
 
-    /**
-     * Compute an Irreducible Inconsistent Subsystem (IIS)
-     * @return the irreducible inconsistent rows and columns
-     */
+    @Override
     public IIS computeIIS() {
         final List<Integer> idxRows = new ArrayList<Integer>();
         final List<Integer> idxCols = new ArrayList<Integer>();
Index: src/main/java/example/MdoLoDiet1.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/example/MdoLoDiet1.java b/src/main/java/example/MdoLoDiet1.java
--- a/src/main/java/example/MdoLoDiet1.java	(revision 34ac7d76b3f2aeea4e46af406b6d01ff6dc81f23)
+++ b/src/main/java/example/MdoLoDiet1.java	(revision 73580d486d62fa3dee4c93db3dc72601a64d6bb5)
@@ -207,7 +207,11 @@
 
         // Load native library
         Mdo.load(libraryPath);
-        MdoModel model = new MdoModel();
+
+        // Create mindopt environment and create mindopt models through mindopt environment.
+        // The previous interface for creating models `MdoModel()` is about to be deprecated.
+        MdoEnv env = new MdoEnv();
+        MdoModel model = env.createModel();
 
         try {
             model.setMinObjSense();
@@ -284,6 +288,9 @@
             // Or it will be freed automatically after a system GC
             // But native memory usage is GC-invisible, GC may not be triggered
             model.free();
+
+            // Free environment is necessary if you creatModel throng environment.
+            env.free();
         }
     }
 }
Index: src/main/java/example/MdoLoDiet2.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/example/MdoLoDiet2.java b/src/main/java/example/MdoLoDiet2.java
--- a/src/main/java/example/MdoLoDiet2.java	(revision 34ac7d76b3f2aeea4e46af406b6d01ff6dc81f23)
+++ b/src/main/java/example/MdoLoDiet2.java	(revision 73580d486d62fa3dee4c93db3dc72601a64d6bb5)
@@ -207,7 +207,11 @@
 
         // Load native library
         Mdo.load(libraryPath);
-        MdoModel model = new MdoModel();
+
+        // Create mindopt environment and create mindopt models through mindopt environment.
+        // The previous interface for creating models `MdoModel()` is about to be deprecated.
+        MdoEnv env = new MdoEnv();
+        MdoModel model = env.createModel();
 
         try {
             model.setIntAttr(Mdo.INT_ATTR_MIN_SENSE, 1);
@@ -292,6 +296,9 @@
             // Or it will be freed automatically after a system GC
             // But native memory usage is GC-invisible, GC may not be triggered
             model.free();
+
+            // Free environment is necessary if you creatModel throng environment.
+            env.free();
         }
     }
 }
Index: src/main/java/example/MdoQoEx1.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/example/MdoQoEx1.java b/src/main/java/example/MdoQoEx1.java
new file mode 100644
--- /dev/null	(revision 73580d486d62fa3dee4c93db3dc72601a64d6bb5)
+++ b/src/main/java/example/MdoQoEx1.java	(revision 73580d486d62fa3dee4c93db3dc72601a64d6bb5)
@@ -0,0 +1,112 @@
+/**
+ * Copyright 1999-2021 Alibaba Cloud All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package example;
+
+import com.alibaba.damo.mindopt.*;
+
+/**
+ *  Description
+ *  -----------
+ *
+ *  Quadratic optimization (row-wise input).
+ *
+ *  Formulation
+ *  -----------
+ *
+ *  Minimize
+ *    obj: 1 x0 + 1 x1 + 1 x2 + 1 x3
+ *         + 1/2 [ x0^2 + x1^2 + x2^2 + x3^2 + x0 x1]
+ *  Subject To
+ *   c0 : 1 x0 + 1 x1 + 2 x2 + 3 x3 >= 1
+ *   c1 : 1 x0 - 1 x2 + 6 x3 = 1
+ *  Bounds
+ *    0 <= x0 <= 10
+ *    0 <= x1
+ *    0 <= x2
+ *    0 <= x3
+ *  End
+ */
+
+public class MdoQoEx1 {
+    public static void main(String[] args) {
+        String libraryPath = System.getenv("MDO_NATIVE_LIBRARY");
+        if (libraryPath == null) {
+            System.err.println("Env variable MDO_NATIVE_LIBRARY needs to be set");
+            System.exit(1);
+        }
+
+        // Load native library
+        Mdo.load(libraryPath);
+
+        // Create mindopt environment and create mindopt models through mindopt environment.
+        // The previous interface for creating models `MdoModel()` is about to be deprecated.
+        MdoEnv env = new MdoEnv();
+        MdoModel model = env.createModel();
+
+        try {
+            // Change to minimization problem
+            model.setMinObjSense();
+
+            // Create variables
+            MdoVar[] x = new MdoVar[4];
+            x[0] = model.addVar(0.0, 10.0, 1.0, false, "x0");
+            x[1] = model.addVar(0.0, Mdo.INFINITY, 1.0, false, "x1");
+            x[2] = model.addVar(0.0, Mdo.INFINITY, 1.0, false, "x2");
+            x[3] = model.addVar(0.0, Mdo.INFINITY, 1.0, false, "x3");
+
+            // Add constraints
+            MdoExprLinear c0 = new MdoExprLinear();
+            c0.addTerm(1.0, x[0]);
+            c0.addTerm(1.0, x[1]);
+            c0.addTerm(2.0, x[2]);
+            c0.addTerm(3.0, x[3]);
+            model.addCons(c0, Mdo.GREATER_EQUAL, 1.0, "c0");
+
+            MdoExprLinear c1 = new MdoExprLinear();
+            c1.addTerm(1.0, x[0]);
+            c1.addTerm(-1.0, x[2]);
+            c1.addTerm(6.0, x[3]);
+            model.addCons(c1, Mdo.EQUAL, 1.0, "c1");
+
+            // Add quadratic objective matrix Q
+            MdoExprQuad obj = new MdoExprQuad();
+            obj.addTerm(1.0, x[0], x[0]);
+            obj.addTerm(0.5, x[1], x[0]);
+            obj.addTerm(1.0, x[1], x[1]);
+            obj.addTerm(1.0, x[2], x[2]);
+            obj.addTerm(1.0, x[3], x[3]);
+            model.setQuadraticElements(obj.getVars1(), obj.getVars2(), obj.getCoeffs());
+
+            // Solve model
+            model.solveProb();
+            model.displayResult();
+
+        } catch (MdoException e) {
+            System.out.println("Received Mindopt exception.");
+            System.out.println(" - Code          : " + e.getCode());
+            System.out.println(" - Reason        : " + e.getMessage());
+        } finally {
+            // Optionally, you can free native memory in time manually
+            // Or it will be freed automatically after a system GC
+            // But native memory usage is GC-invisible, GC may not be triggered
+            model.free();
+
+            // Free environment is necessary if you creatModel throng environment.
+            env.free();
+        }
+    }
+}
Index: src/main/java/com/alibaba/damo/mindopt/MdoSolver.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/alibaba/damo/mindopt/MdoSolver.java b/src/main/java/com/alibaba/damo/mindopt/MdoSolver.java
new file mode 100644
--- /dev/null	(revision 1562808c594777f48ccfdb11b85f20aec0f1948c)
+++ b/src/main/java/com/alibaba/damo/mindopt/MdoSolver.java	(revision 1562808c594777f48ccfdb11b85f20aec0f1948c)
@@ -0,0 +1,203 @@
+package com.alibaba.damo.mindopt;
+
+import java.util.List;
+
+public interface MdoSolver {
+    enum RemoteTaskStatus {
+        /**
+         * This task is prepared to be scheduled
+         */
+        Submitted,
+        /**
+         * This task is now in solving phase
+         */
+        Solving,
+        /**
+         * This task is canceled
+         */
+        Canceled,
+        /**
+         * This task is finished (OPTIMAL, INFEASIBLE ...)
+         */
+        Finished,
+        /**
+         * This task is failed
+         */
+        Failed
+    }
+
+    interface MdoRemoteTask {
+        /**
+         * Get the remote task status code
+         * @return the remote task status code
+         */
+        int getStatusCode();
+
+        /**
+         * Get the remote task status (OPTIMAL, INFEASIBLE ...)
+         * @return the remote task status (OPTIMAL, INFEASIBLE ...)
+         */
+        MdoStatus getStatus();
+
+        /**
+         * Get the remote task result code
+         * @return the remote task status code
+         */
+        int getResultCode();
+
+        /**
+         * Get the remote task result status (MDO_OK ...)
+         * @return the remote task result status (MDO_OK ...)
+         */
+        MdoResult getResult();
+
+        /**
+         * Check weather remote task has a solution
+         * @return weather remote task has a solution
+         */
+        boolean hasSolution();
+
+        /**
+         * Get remote task job status (Submitted, Solving...)
+         * @return remote task job status (Submitted, Solving...)
+         */
+        MdoModel.RemoteTaskStatus getRemoteTaskStatus();
+    }
+
+    /**
+     * Irreducible Inconsistent Subsystem
+     */
+    interface IIS {
+        /**
+         * Get all constraints involved in an IIS
+         * @return all constraints involved in an IIS
+         */
+        List<Integer> getRowIndices();
+
+        /**
+         * Get all variables involved in an IIS
+         * @return all variables involved in an IIS
+         */
+        List<Integer> getColIndices();
+    }
+
+    /**
+     * Log callback
+     */
+    interface LogCallback {
+        /**
+         * log message
+         * @param msg the message
+         */
+        void log(String msg);
+    }
+
+    /**
+     * Load problem to model from file.
+     *
+     * Note that the type of the inputted format is determined by the file suffix, valid suffixes are `.mps(.bz2/.gz)` or `.lp(.bz2/.gz)`
+     * @param filename the file name
+     */
+    void readProb(String filename);
+
+    /**
+     * Write problem to file.
+     *
+     * Note that the type of the outputted format is determined by the file suffix, valid suffixes are `.mps(.bz2/.gz)` or `.lp(.bz2/.gz)`
+     * @param filename the file name
+     */
+    void writeProb(String filename);
+
+    /**
+     * Write solution to a file.
+     *
+     * Note that the format of the solution is determined by the file suffix, valid suffixes are `.sol` or `.bas`.
+     * @param filename the file name
+     */
+    void writeSoln(String filename);
+
+    /**
+     * Load optimization model task from a file.
+     * @param filename the file name
+     * @param readModel a boolean flag that specifies if the model shall be loaded
+     * @param readParam a boolean flag that specifies if the parameters shall be loaded
+     * @param readSoln a boolean flag that specifies if the solution shall be loaded
+     */
+    void readTask(String filename, boolean readModel, boolean readParam, boolean readSoln);
+
+
+    /**
+     * Write an optimization model task to a file
+     * @param filename the file name
+     * @param writeModel a boolean flag that specifies if the model shall be outputted
+     * @param writeParam a boolean flag that specifies if the parameters shall be outputted
+     * @param writeSoln a boolean flag that specifies if the solution shall be outputted
+     */
+    void writeTask(String filename, boolean writeModel, boolean writeParam, boolean writeSoln);
+
+    /**
+     * Submit an optimization model task to a remote server for optimization
+     * @return the remote task id
+     */
+    String submitTask();
+
+    /**
+     * Retrieve remote task status by its task id
+     * @param jobId the task id returned on task submission
+     * @return remote task status
+     */
+    MdoModel.MdoRemoteTask retrieveTask(String jobId);
+
+    /**
+     * Print log to standard output or not
+     * @param flag a flag that specified if the log shall be printed out to screen or not
+     */
+    void setLogToConsole(boolean flag);
+
+    /**
+     * Redirect log to a file
+     * @param filename the file name
+     */
+    void setLogFile(String filename);
+    /**
+     * Customize log output to a user-defined callback
+     * @param logCallback the log callback function wrapper class
+     */
+    void setLogCallback(final MdoModel.LogCallback logCallback);
+
+    /**
+     * Solve the loaded optimization problem
+     */
+    void solveProb();
+
+    /**
+     * Display the current solver results
+     */
+    void displayResult();
+
+    /**
+     * Get the current solver status
+     * @return the solver status
+     */
+    MdoStatus getStatus();
+
+    /**
+     * Explain the solver status enumeration
+     * @param status the status to explain
+     * @return a string that holds the explanation of the solver status enumeration
+     */
+    String explainStatus(MdoStatus status);
+
+    /**
+     * Explain the solver result enumeration
+     * @param result the result to explain
+     * @return a string that holds the explanation of the solver result enumeration
+     */
+    String explainResult(MdoResult result);
+
+    /**
+     * Compute an Irreducible Inconsistent Subsystem (IIS)
+     * @return the irreducible inconsistent rows and columns
+     */
+    MdoModel.IIS computeIIS();
+}
Index: src/main/java/com/alibaba/damo/mindopt/impl/MdoConsImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/alibaba/damo/mindopt/impl/MdoConsImpl.java b/src/main/java/com/alibaba/damo/mindopt/impl/MdoConsImpl.java
--- a/src/main/java/com/alibaba/damo/mindopt/impl/MdoConsImpl.java	(revision c2536b971962526afee94e63564e04615d47325d)
+++ b/src/main/java/com/alibaba/damo/mindopt/impl/MdoConsImpl.java	(revision ce1a24e12f8193b9c421115cfcf00ab3d91f3152)
@@ -16,17 +16,17 @@
 
 package com.alibaba.damo.mindopt.impl;
 
-import com.alibaba.damo.mindopt.MdoMatrix;
+import com.alibaba.damo.mindopt.MdoProblem;
 import com.alibaba.damo.mindopt.MdoCons;
 import com.alibaba.damo.mindopt.MdoVar;
 
 import java.util.Arrays;
 
-class MdoConsImpl implements MdoCons {
-    MdoMatrix model;
+public class MdoConsImpl implements MdoCons {
+    MdoProblem model;
     int index;
 
-    public MdoConsImpl(MdoMatrix model, int index) {
+    public MdoConsImpl(MdoProblem model, int index) {
         this.model = model;
         this.index = index;
     }
Index: src/main/java/com/alibaba/damo/mindopt/impl/MdoNativeEnv.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/alibaba/damo/mindopt/impl/MdoNativeEnv.java b/src/main/java/com/alibaba/damo/mindopt/impl/MdoNativeEnv.java
new file mode 100644
--- /dev/null	(revision 1562808c594777f48ccfdb11b85f20aec0f1948c)
+++ b/src/main/java/com/alibaba/damo/mindopt/impl/MdoNativeEnv.java	(revision 1562808c594777f48ccfdb11b85f20aec0f1948c)
@@ -0,0 +1,55 @@
+package com.alibaba.damo.mindopt.impl;
+
+import com.sun.jna.Pointer;
+import com.sun.jna.ptr.PointerByReference;
+
+/**
+ * The mindopt environment native interface, it is strongly recommended to use MdoEnv instead
+ */
+public class MdoNativeEnv {
+    static MdoNativeAPI inst() {
+        if (MdoNativeAPI.InstanceHolder.get() == null) {
+            throw new RuntimeException("Mdo.load() needs to be called at very beginning.");
+        }
+        return MdoNativeAPI.InstanceHolder.get();
+    }
+
+    private Pointer getEnv() {
+        return env.getValue();
+    }
+    private PointerByReference env = new PointerByReference();
+
+    /**
+     * Create a mindopt environment with default parameter settings.
+     * @return MdoResult code
+     */
+    public int createEnv(
+    ) {
+        return inst().Mdo_createEnv(
+                env
+        );
+    }
+
+    /**
+     * Create a mindopt environment with default parameter settings.
+     * @return MdoResult code
+     */
+    public int createMdlWithEnv(
+            MdoNativeModel model
+    ) {
+        return inst().Mdo_createMdlWithEnv(
+                model.model,
+                env.getValue()
+        );
+    }
+
+    /**
+     * Destroy an env and all associated data.
+     */
+    public void freeEnv(
+    ) {
+        inst().Mdo_freeEnv(
+                env
+        );
+    }
+}
Index: src/main/java/com/alibaba/damo/mindopt/impl/MdoVarImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/alibaba/damo/mindopt/impl/MdoVarImpl.java b/src/main/java/com/alibaba/damo/mindopt/impl/MdoVarImpl.java
--- a/src/main/java/com/alibaba/damo/mindopt/impl/MdoVarImpl.java	(revision c2536b971962526afee94e63564e04615d47325d)
+++ b/src/main/java/com/alibaba/damo/mindopt/impl/MdoVarImpl.java	(revision ce1a24e12f8193b9c421115cfcf00ab3d91f3152)
@@ -17,16 +17,16 @@
 package com.alibaba.damo.mindopt.impl;
 
 import com.alibaba.damo.mindopt.MdoCons;
-import com.alibaba.damo.mindopt.MdoMatrix;
+import com.alibaba.damo.mindopt.MdoProblem;
 import com.alibaba.damo.mindopt.MdoVar;
 
 import java.util.Arrays;
 
-class MdoVarImpl implements MdoVar {
-    MdoMatrix model;
+public class MdoVarImpl implements MdoVar {
+    MdoProblem model;
     int index;
 
-    public MdoVarImpl(MdoMatrix model, int index) {
+    public MdoVarImpl(MdoProblem model, int index) {
         this.model = model;
         this.index = index;
     }
Index: src/main/java/com/alibaba/damo/mindopt/MdoMatrix.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/alibaba/damo/mindopt/MdoMatrix.java b/src/main/java/com/alibaba/damo/mindopt/MdoProblem.java
rename from src/main/java/com/alibaba/damo/mindopt/MdoMatrix.java
rename to src/main/java/com/alibaba/damo/mindopt/MdoProblem.java
--- a/src/main/java/com/alibaba/damo/mindopt/MdoMatrix.java	(revision 04a30f71ef197800d26eed246753aad99b81350a)
+++ b/src/main/java/com/alibaba/damo/mindopt/MdoProblem.java	(revision ce1a24e12f8193b9c421115cfcf00ab3d91f3152)
@@ -16,7 +16,7 @@
 
 package com.alibaba.damo.mindopt;
 
-public interface MdoMatrix extends MdoAttrAccessor, MdoParamAccessor {
+public interface MdoProblem extends MdoAttrAccessor, MdoParamAccessor {
     /**
      * Add a single decision variable
      * @param lb lower bound for this variable, set to {@code -Mdo.INFINITY} if it's lower-bound-free
@@ -391,6 +391,40 @@
      */
     void deleteElements(MdoCons[] conss, MdoVar[] vars);
 
+    /**
+     * Delete all elements from the constraint matrix.
+     */
+    void deleteAllElements();
+
+    /**
+     * Retrieve a set of values of all specified elements in the quadratic matrix of a quadratic program.
+     * @param vars1 array that holds the first variable of quadratic terms.
+     * @param vars2 array that holds the second variable of quadratic terms.
+     * @return array of current nonzero values of all specified terms.
+     */
+    double[] getQuadraticElements(MdoVar[] vars1, MdoVar[] vars2);
+
+    /**
+     * Modify a set of values of all specified elements in the quadratic matrix of a quadratic program.
+     * @param vars1 array that holds the first variable of quadratic terms.
+     * @param vars2 array that holds the second variable of quadratic terms.
+     * @param values array that holds the coefficient of all specified terms.
+     */
+    void setQuadraticElements(MdoVar[] vars1, MdoVar[] vars2, double[] values);
+
+    /**
+     * Delete a set of elements from the quadratic matrix of a quadratic program.
+     * @param vars1 array that holds the first variable of quadratic terms.
+     * @param vars2 array that holds the second variable of quadratic terms.
+     */
+    void deleteQuadraticElements(MdoVar[] vars1, MdoVar[] vars2);
+
+
+    /**
+     * Delete all elements from the quadratic matrix of a quadratic program.
+     */
+    void deleteAllQuadraticElements();
+
     /**
      * Change the value of a string-valued model attribute
      * @param att the attribute name
